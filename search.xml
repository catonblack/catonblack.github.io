<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[if……else 和 case 的综合结果]]></title>
    <url>%2F2019-07-17%2Fif-else%2F</url>
    <content type="text"><![CDATA[在某些资料中关于if else和case的综合结果有着不同的结论，有的资料表明虽然RTL原理图综合结果差别比较大但是最后的technology map确实一样的；而有的资料里又说if else这种结构会产生先后顺序，这样就意味着和case语句生成的结果应该不一样。网上的资料各有各的理论依据和实际结果，到底哪个是正确的谁也没个结果。为了一探究竟，我专门做了这个实验。 实验目的探究如下内容： [√] 1. if else 和 case 在不同的综合器中的综合结果是咋样的？ [√] 2. 硬件上的先后顺序到底是怎么实现的？ [√] 3. 针对组合逻辑电路和时序逻辑电路的综合结果是否有区别？ [√] 4. If else有先后顺序和无先后顺序是怎么实现的？ [√] 5. 不同综合器的综合结果对整体结果的影响？ [√] 6. 组合逻辑电路中如果else为空会怎么样？ 如果你懒得看下面的过程，请点击传送门：实验结论 实验内容实验一Code： 12345678910111213141516171819module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验二Code： 12345678910111213141516171819202122module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b00) data &lt;= 2'b00; else begin end endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验三Code： 12345678910111213141516171819module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验四Code： 1234567891011121314151617181920module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验五Code： 123456789101112131415module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00;endendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验六Code： 123456789101112131415161718module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else begin endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验七Code: 123456789101112131415module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验八Code： 12345678910111213141516module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验九Code： 1234567891011121314151617module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else data &lt;= 2'b10;endendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验十Code： 12345678910111213141516module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default: data &lt;= 2'b10; endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验十一 always@(*) begin Z = A[4]; if (C[0] == 1'b1 ) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; else Z = A[4]; //可以放在此位置 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; else Z = A[4]; //可以放在此位置 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; else Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; //放在此处，上面的if被阻塞 end always@(*) begin if (C[0] == 1'b1) Z = A[0]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; Z = A[4]; //放在此处，上面的if被阻塞 end always@(*) begin if (C[0] == 1'b1 ) Z = A[0]; else if (C[1] == 1'b1) Z = A[1]; else if (C[2] == 1'b1) Z = A[2]; else if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; end 结果分析 对比实验一和二，三和四，以Xilinx为例，可以得出：在时序逻辑电路中，if..else写不写else都会综合成正确的结果，case有没有default也都会综合成正确的结果； always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end end always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b00) data &lt;= 2'b00; else begin end end end a) 实验一 ISE Spartan6 Technological 原理图 b) 实验二 ISE Spartan6 Technological 原理图 always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end end always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcase end end c) 实验三 ISE Spartan6 Technological 原理图 d) 实验四 ISE Spartan6 Technological 原理图 对比实验一和二，三和四，五和六，七和八，可以得出：无论是组合逻辑电路还是时序逻辑电路，如果else或default的内容为空，那么其综合结果与这部分不写是一样的，这点跟软件完全不一样，这点要注意； always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else begin end end a) 实验五 ISE Spartan6 Technological 原理图 b) 实验六 ISE Spartan6 Technological 原理图 always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcase end c) 实验七 ISE Spartan6 Technological 原理图 d) 实验八 ISE Spartan6 Technological 原理图 但是对比实验五和九，七和十，可以得出：组合逻辑电路中，if…else如果省略else，就会综合成锁存器，包含else就不会综合出锁存器，这点在case语句中也一样； always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else data &lt;= 2'b10; end a) 实验五 ISE Spartan6 Technological 原理图 b) 实验九 ISE Spartan6 Technological 原理图 always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default: data &lt;= 2'b10; endcase end c) 实验七 ISE Spartan6 Technological 原理图 d) 实验十 ISE Spartan6 Technological 原理图 对比实验一和三，可以得出：对于时序逻辑电路，ISE中if…else的综合结果与相同条件下case的综合结果不相同，quartusii与synplify中，这两种情况的综合结果是相同的。ISE的综合结果中，case要少用一个lut和fdr，总的来说case的综合结果应该是更好一点的；现在看来ise的性能的确不怎么地。。。Vivado中两者的综合结果已经很接近了，但是case的综合结果依然会少一根线，看样子还是case胜出。 always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end end always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end end a) 实验一 ISE Spartan6 Technological 原理图 b) 实验三 ISE Spartan6 Technological 原理图 c) 实验一 VIVADO ZYNQ7 Technological 原理图 d) 实验三 VIVADO ZYNQ7 Technological 原理图 e) 实验一 Synplify Spartan6 Technological 原理图 f) 实验三 Synplify Spartan6 Technological 原理图 g) 实验一 Quartus Cyclone IV E Technological 原理图 h) 实验三 Quartus Cyclone IV E Technological 原理图 i) 实验一 Synplify Cyclone IV E Technological 原理 j) 实验三 Synplify Cyclone IV E Technological 原理 对比实验五和七，可以得出：对于组合逻辑电路，if…else和case在ISE中的综合结果不相同，case的结果要更加节省资源一点；if…else和case在Quartus中的综合结果也不相同，case的结果使用的资源更少一点；而在Synplify中，if…else和case的综合结果是完全一致的；vivado中case的综合结果更加符合预期，少用一根线。总的来说还是case的综合结果更好一点。 always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end a) 实验五 ISE Spartan6 Technological 原理图 b) 实验七 ISE Spartan6 Technological 原理图 c) 实验五 VIVADO ZYNQ7 Technological 原理图 d) 实验七 VIVADO ZYNQ7 Technological 原理图 e) 实验五 Synplify Spartan6 Technological 原理图 f) 实验七 Synplify Spartan6 Technological 原理图 g) 实验五 Quartus Cyclone IV E Technological 原理图 h) 实验七 Quartus Cyclone IV E Technological 原理图 i) 实验五 Synplify Cyclone IV E Technological 原理 j) 实验七 Synplify Cyclone IV E Technological 原理 接上条，对比的过程中发现Quartus的综合器会将锁存器的输出与其中一个输入相连，形成闭环，推测Quartus综合器在综合的过程中会自动将条件补全并输出当前值。 由于Quartus生成的RTL视图可读性比较好，所以这些实验使用Quartus来综合。else放在最开始就相当于给之后的所有if添加默认输出； always@(*) begin if (C[0] == 1'b1 ) Z = A[0]; else if (C[1] == 1'b1) Z = A[1]; else if (C[2] == 1'b1) Z = A[2]; else if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; end always@(*) begin Z = A[4]; if (C[0] == 1'b1 ) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end 放在其他位置时，else会阻塞前面的if语句，假如放在第4个if后面的else 里面，那么前面3个if就被阻塞了，因为第4个的else中已经包含了前三个if语句的条件，要时刻记住always块中的阻塞赋值生成的组合逻辑电路是按照顺利执行的。 既然是按照顺序，那第4个if的else里面已经包含了前面的if条件，那么前面条件就没有意义，而综合软件在进行综合时，就将前面3个if语句优化掉，即不会生成对应的电路。同样道理，放在第一个if后面的else中是可以的。 always@(*) begin if (C[0] == 1'b1) Z = A[0]; else Z = A[4]; //可以放在此位置 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; else Z = A[4]; //可以放在此位置 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; else Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; //放在此处，上面的if被阻塞 end 没有else也会有阻塞产生，只不过会比有else的多阻塞一下。 always@(*) begin Z = A[4]; if (C[0] == 1'b1 ) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; Z = A[4]; //放在此处，上面的if被阻塞 end 结论 时序逻辑电路中if…else无论有没有else，case无论有没有default，都可以综合成正确的电路；但是在组合逻辑电路中，if如果没有else（包括else内容为空或保持输出）/ case如果没有default（包括default内容为空或保持输出），就会综合出锁存器，如果补全了else选项就会综合出相应的组合逻辑电路； 不同综合器对于if…else和case的综合结果不尽相同，总的来说还是case的综合结果更好； 对比if…else和case的综合结果，对于时序逻辑电路，Synplify=Quartusii&gt;Vivado&gt;ISE；对于组合逻辑电路，Synplify&gt;Quartusii&gt;Vivado&gt;ISE，Synplify的优点主要是更加智能； 对于像Synplify和Quartusii这样的综合器，其实if…else和case的综合结果是几乎一样的，这说明综合器越来越聪明，但是考虑到代码的可移植性，还是用case更好一点； 在组合逻辑电路中，目前已知只有实验中的Quartus会自动将条件补全并输出当前值，但是综合器依然会生成锁存器； 如果有多个if，第一个else会默认成为之后所有if的默认值； else如果放在其他位置，会阻塞前面的所有if语句，所以放在不同的位置也就会产生不同的综合结果，所以这里的编码原则就是尽可能让代码没有歧义； 其实硬件电路本身是没有优先级之分的，对于if这样的语法，最好是可以实现条件互斥，如果条件本身不能互斥，那么综合器会扩展这些条件，然后根据扩展后的真值表进行结果判断。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Verilog中if..else和case语句分析 关于FPGA中是用if-else还是select-case Verilog——if语句的优先级问题 状态机跑飞的例子 多路选择器]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>if……else</tag>
        <tag>case</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态机一段式、二段式和三段式写法的实际效果]]></title>
    <url>%2F2019-07-16%2Ffsm-style%2F</url>
    <content type="text"><![CDATA[根据写法不同，状态机分为一段式状态机、两段式状态机和三段式状态机。对于硬件描述语言来说，不同的写法往往会综合出不同的硬件电路。网上大多数资料都仅仅只是介绍了各种状态机的写法，而今天我要来研究研究不同写法综合出来的实际结果的差异。 好的状态机标准好的状态机的标准很多，最重要的几个方面如下： 状态机要安全，是指FSM不会进入死循环，特别是不会进入非预知的状态，而且由于某些扰动进入非设计状态，也能很快的恢复到正常的状态循环中来。这里面有两层含义：其一要求该FSM的综合实现结果无毛刺等异常扰动；其二要求FSM要完备，即使受到异常扰动进入非设计状态，也能很快恢复到正常状态。 状态机的设计要满足设计的面积和速度的要求。 状态机的设计要清晰易懂、易维护。 有限状态机有三种常见的编写方法，一段式，两段式和三段式，他们各自有着不同的优缺点，下面将进行对比。 一段式状态机 不推荐当把整个状态机写在一个always模块中，并且这个模块既包含状态转移，又含有组合逻辑输入/输出时，称为一段式状态机。不推荐采用这种状态机，因为从代码风格方面来讲，一般都会要求把组合逻辑和时序逻辑分开；从代码维护和升级来说，组合逻辑和书序逻辑混合在一起不利于代码维护和修改，也不利于约束。 特点: 1. 将所有的逻辑写在一个always块中，增加代码复杂度，给后期更改维护带来不便。 2. 由于其中有状态寄存器，整体使用non-blockin，描述输出组合逻辑时，需要提前一个时钟，需要额外注意。Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] q_sm_state );//parameterparameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//statemachinealways @(posedge clk or posedge rst) begin if(rst) begin q_sig4 &lt;= 0; q_sm_state &lt;= IDLE; end else begin case(q_sm_state) IDLE: begin if(sig1 || sig2) begin q_sm_state &lt;= WAIT; q_sig4 &lt;= 1'b0; end else begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 1'b0; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin q_sm_state &lt;= DONE; q_sig4 &lt;= 1'b0; end else begin q_sm_state &lt;= WAIT; q_sig4 &lt;= 1'b0; end end DONE:begin if(sig3) begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 1'b1; end else begin q_sm_state &lt;= DONE; q_sig4 &lt;= 1'b0; end end default: begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 0; end endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 两段式状态机 推荐使用所谓的两段式状态机就是采用一个always语句来实现时序逻辑，另外一个always语句来实现组合逻辑，提高了代码的可读性，易于维护。不同于一段式状态机的是，它需要定义两个状态—-现态和次态，然后通过现态和次态的转换来实现时序逻辑。 特点: 1. 两段式状态机可以较清晰完整的显示出状态机的结构。 2. 可以轻易的将状态图state diagram转换为verilog code。 3. 代码清晰，降低编写维护复杂度。Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] current_state );reg [1:0] next_state;//参数声明parameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//状态跳转程序设计always @(posedge clk or posedge rst) if(rst) current_state &lt;= IDLE; else current_state &lt;= next_state; //状态逻辑输出always @(*) begin case(current_state) IDLE: begin if(sig1 || sig2) begin next_state = WAIT; q_sig4 = 1'b0; end else begin next_state = IDLE; q_sig4 = 1'b0; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin next_state = DONE; q_sig4 = 1'b0; end else begin next_state = WAIT; q_sig4 = 1'b0; end end DONE:begin if(sig3) begin next_state = IDLE; q_sig4 = 1'b1; end else begin next_state = DONE; q_sig4 = 1'b0; end end default: begin next_state = IDLE; q_sig4 = 0; end endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 三段式状态机 推荐使用三段式状态机与两段式状态机的区别：两段式直接采用组合逻辑输出，而三段式则通过在组合逻辑后再增加一级寄存器来实现时序逻辑输出。这样做的好处是可以有效地滤去组合逻辑输出的毛刺，同时可以有效地进行时序计算与约束，另外对于总线形式的输出信号来说，容易使总线数据对齐，从而减小总线数据间的偏移，减小接收端数据采样出错的频率。三段式状态机的基本格式是：第一个always语句实现同步状态跳转；第二个always语句实现组合逻辑；第三个always语句实现同步输出。 特点: 1. 三段式状态机可以清晰完整的显示出状态机的结构。 2. 可以轻易的将状态图state diagram转换为verilog code。 3. 代码清晰，降低编写维护复杂度。 4. 在简单状态机（状态少，转移条件少这类）的应用上，三段式代码量和一二段的比较起来长些。Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] current_state );reg [1:0] next_state;//参数声明parameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//状态跳转程序设计always @(posedge clk or posedge rst) if(rst) current_state &lt;= IDLE; else current_state &lt;= next_state;//状态跳转输出always @(*) begin case(current_state) IDLE: begin if(sig1 || sig2) begin next_state = WAIT; end else begin next_state = IDLE; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin next_state = DONE; end else begin next_state = WAIT; end end DONE:begin if(sig3) begin next_state = IDLE; end else begin next_state = DONE; end end default: begin next_state = IDLE; end endcaseend//逻辑输出always @(posedge clk or posedge rst) if(rst) q_sig4 &lt;= 1'b0; else begin case(next_state) IDLE, WAIT: q_sig4 &lt;= 1'b0; DONE: q_sig4 &lt;= 1'b1; default: q_sig4 &lt;= 1'b0; endcase endendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 刚才的例子是一个三状态Moore状态机，状态少，也比较简单，区别效果不是很明显，接下来看一个四状态的Moore状态机，状态机之间的跳转也更加复杂。 一段式状态机Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg out );reg [2:0] NS; //NextStateparameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//1 always block to describe state transition, state output, input conditionalways @ (posedge clk or posedge rst) begin if (rst) begin NS &lt;= IDLE; out &lt;= 3'b000; end else begin case (NS) IDLE: begin if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (i1 &amp;&amp; i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i1 &amp;&amp; ~i2) begin out&lt;=3'b111;NS &lt;= ERROR;end end S1: begin if (~i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i2 &amp;&amp; i1) begin out&lt;=3'b010;NS &lt;= S2; end if (i2 &amp;&amp; (~i1)) begin out&lt;=3'b111;NS &lt;= ERROR;end end S2: begin if (i2) begin out&lt;=3'b010;NS &lt;= S2; end if (~i2 &amp;&amp; i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (~i2 &amp;&amp; (~i1))begin out&lt;=3'b111;NS &lt;= ERROR;end end ERROR: begin if (i1) begin out&lt;=3'b111;NS &lt;= ERROR;end if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end end endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 两段式状态机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg out );reg [2:0] NS,CS;parameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= IDLE; else CS &lt;=NS;//combinational condition judgmentalways @ (*) begin case (CS) IDLE: begin if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (i1 &amp;&amp; i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i1 &amp;&amp; ~i2) begin out&lt;=3'b111;NS &lt;= ERROR;end end S1: begin if (~i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i2 &amp;&amp; i1) begin out&lt;=3'b010;NS &lt;= S2; end if (i2 &amp;&amp; (~i1)) begin out&lt;=3'b111;NS &lt;= ERROR;end end S2: begin if (i2) begin out&lt;=3'b010;NS &lt;= S2; end if (~i2 &amp;&amp; i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (~i2 &amp;&amp; (~i1))begin out&lt;=3'b111;NS &lt;= ERROR;end end ERROR: begin if (i1) begin out&lt;=3'b111;NS &lt;= ERROR;end if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end end default: begin NS &lt;= CS; out &lt;= 3'b111; end endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 三段式状态机Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg [2:0] out );reg [2:0] NS,CS;//parameter [2:0] //one hot with zero idleparameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= IDLE; else CS &lt;=NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) IDLE: begin if (~i1) NS &lt;= IDLE; if (i1 &amp;&amp; i2) NS &lt;= S1; if (i1 &amp;&amp; ~i2) NS &lt;= ERROR; end S1: begin if (~i2) NS &lt;= S1; if (i2 &amp;&amp; i1) NS &lt;= S2; if (i2 &amp;&amp; (~i1)) NS &lt;= ERROR; end S2: begin if (i2) NS &lt;= S2; if (~i2 &amp;&amp; i1) NS &lt;= IDLE; if (~i2 &amp;&amp; (~i1)) NS &lt;= ERROR; end ERROR: begin if (i1) NS &lt;= ERROR; if (~i1) NS &lt;= IDLE; end default: NS &lt;= CS; endcaseend//3rd always block, the sequential FSM outputalways @ (posedge clk or posedge rst) begin if (rst) begin out &lt;= 3'b000; end else begin case (NS) IDLE: begin if (~i1) out&lt;=3'b000; if (i1 &amp;&amp; i2) out&lt;=3'b100; if (i1 &amp;&amp; ~i2) out&lt;=3'b111; end S1: begin if (~i2) out&lt;=3'b100; if (i2 &amp;&amp; i1) out&lt;=3'b010; if (i2 &amp;&amp; (~i1)) out&lt;=3'b111; end S2: begin if (i2) out&lt;=3'b010; if (~i2 &amp;&amp; i1) out&lt;=3'b000; if (~i2 &amp;&amp; (~i1))out&lt;=3'b111; end ERROR: begin if (i1) out&lt;=3'b111; if (~i1) out&lt;=3'b000; end default: out&lt;=3'b111; endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 结果分析1.三状态Moore状态机综合结果排序：三段式&gt;两段式&gt;一段式。可以看出，相对于一段式状态机，两段式状态机和三段式状态机所需要的硬件资源更少。 一段式 两段式 三段式 a) ISE Spartan6 RTL 原理图 b) ISE Spartan6 RTL 原理图 c) ISE Spartan6 RTL 原理图 d) ISE Spartan6 Technological 原理图 e) ISE Spartan6 Technological 原理图 f) ISE Spartan6 Technological 原理图 g) Synplify Spartan6 Technological 原理图 h) Synplify Spartan6 Technological 原理图 i) Synplify Spartan6 Technological 原理图 j) Quartus Cyclone IV E RTL 原理图 k) Quartus Cyclone IV E RTL 原理图 l) Quartus Cyclone IV E RTL 原理图 m) Quartus Cyclone IV E Technological 原理图 n) Quartus Cyclone IV E Technological 原理图 o) Quartus Cyclone IV E Technological 原理图 p) Synplify Cyclone IV E Technological 原理图 q) Synplify Cyclone IV E Technological 原理图 r) Synplify Cyclone IV E Technological 原理图 2.四状态Moore机的综合结果，两段式的资源消耗最少，三段式和一段式的综合结果就不一定了，有的情况是三段式更加节省资源，有的时候居然是一段式更加节省资源。 一段式 两段式 三段式 a) ISE Spartan6 RTL 原理图 b) ISE Spartan6 RTL 原理图 c) ISE Spartan6 RTL 原理图 d) ISE Spartan6 Technological 原理图 e) ISE Spartan6 Technological 原理图 f) ISE Spartan6 Technological 原理图 g) Synplify Spartan6 Technological 原理图 h) Synplify Spartan6 Technological 原理图 i) Synplify Spartan6 Technological 原理图 j) Quartus Cyclone IV E RTL 原理图 k) Quartus Cyclone IV E RTL 原理图 l) Quartus Cyclone IV E RTL 原理图 m) Quartus Cyclone IV E Technological 原理图 n) Quartus Cyclone IV E Technological 原理图 o) Quartus Cyclone IV E Technological 原理图 p) Synplify Cyclone IV E Technological 原理图 q) Synplify Cyclone IV E Technological 原理图 r) Synplify Cyclone IV E Technological 原理图 3.时序对比，预估时钟频率一段式和两段式的最高，三段式的频率反而最低。 一段式/MHz两段式/MHz三段式/MHz 3SM_Moore_Xilinx678.6678.6675 3SM_Moore_Altera907.9907.9907.9 4SM_Moore_Xilinx682.2682.2670.3 4SM_Moore_Altera919.6919.6907.3 4.网上找到的三种描述状态机方法的比较 5.小插曲在进行综合的过程中遇到了一个有意思的问题：Synplify没有识别状态机。综合结果只在一段式状态机中提取出了状态机，在两段式和三段式写法中居然没有提取出来。这不科学！要知道Synplify对FSM有专门的处理的，没道理提取不出来。后来发现原因是这样的：两段式和三段式状态机中状态转移部分是组合逻辑电路，一定要补全默认分支，否则就会被综合成锁存器，同时也就不会自动提取状态机信息了，这点要特别注意。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 基于FPGA的有限状态机浅析 Verilog有限状态机三段式描述方法 Verilog学习笔记（四） 有限状态机 FPGA三段式状态机的思维陷阱 Verilog语法_3(同步有限状态机) 三段式状态机设计 有限状态机FSM学习笔记 Verilog三段式状态机描述及模版 FPGA状态机 如何写好状态机]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>有限状态机</tag>
        <tag>多段式状态机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨时钟传递多个时钟信号]]></title>
    <url>%2F2019-07-16%2Fmultisignal-cdc%2F</url>
    <content type="text"><![CDATA[此文是对Clifford E. Cummings 大神的 paper：《Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs》的部分节选与翻译。本人翻译水平有限，还望大家轻拍。以后如果在实际场景中遇到相同或类似的问题，到时候再会补充的。 原文A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. Simply using synchronizers on all control signals is not always good enough as will be shown in the following examples. If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs. 译文对于工程师而言，在处理跨时钟域问题的过程中一个常犯的错误就是在将多个信号从一个时钟域传送到另一个时钟域的过程中忽略控制信号之间的时序。对所有信号仅使用同步器进行同步对于下面要介绍的应用场景是不够的。如果信号顺序和信号间的对齐很重要，那么在处理的过程中就需要格外小心了。接下来举的例子都是简化过后的案例，但是跟实际情况中经常遇到的问题非常类似。 问题1： 传递两个同时需要的信号(b_load和b_en)原文In the simple example shown in Figure 8, a register in the new clock domain requires both a load signal and an enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded. 译文正如下图案例中介绍的那样，在新时钟域中的这个寄存器需要一个负载信号和一个使能信号以保证寄存器的输入值有效。即使负载信号和使能信号都出自于同一个时钟域，两个信号间依然有概率会产生一个小的抖动，这有可能会使这两个信号在新的时钟域被同步入不同的时钟循环。在这个案例中，这就可能导致数据无法被寄存器正确识别。 图1 问题：传递两个同时需要的信号 解决方法：只传递一个信号(b_lden)原文The solution to the problem in this simple example is easy. As shown in Figure 9, drive both the load and enable register input signals in the new clock domain from just one control signal. This will remove the potential for the control signals arriving shifted in time. 译文解决这个问题的方法其实哼简单。正如下图介绍的那样，将寄存器的两个驱动信号合并成一个控制信号，然后传送入新的时钟域。这种方法将移除控制信号到达新时钟域后产生错位的可能。 图2 解决方法：只传递一个信号 问题2：传递两个前后顺序控制的信号(ben1和ben2)原文The diagram in Figure 10, shows two enable signals, aen1 and aen2, that are used to enable the sequential passing of a data signal through a short pipeline design. The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop. 译文下图中的两个使能信号aen1和aen2用于在一个流水线结构中顺序地将数据信号进行传送。这里的问题在于：在第一个时钟域，信号aen1可以在信号aen2置位前立刻结束，但是第二个时钟域可能会对aen1与aen2之间的这个极窄的空隙时间进行采样，这就导致在第二个时钟域中的使能控制信号链会产生一个时钟的空缺，这也将导致a2输出信号被第二个触发器错过。 图3 问题：传递两个前后顺序控制的信号 解决方法：只传递一个信号(ben1)原文The solution to the problem, as shown in Figure 11, is to send only one control signal into the new clock domain and generate the second phase-shifted sequential control signal within the new clock domain. 译文下图显示了解决这个问题的一种方法：将一个时钟信号传递到新的时钟域并在新的时钟域产生第二个相移顺序控制信号。 图4 解决方法：只传递一个信号 问题3：传递两个编码控制信号(bdec[0]和bdec[1])原文The diagram in Figure 12 shows two encoded control signals being passed between clock domains. If the two encoded signals are slightly skewed when sampled, an erroneous decoded output could be generated for one clock period in the new clock domain. 译文下图显示了另外一种常见的问题：两个编码控制信号在时钟域间传递。如果这两个编码控制信号间极窄的抖动被采样到，那么在新的时钟域就会产生一个时钟的编码输出误差。 图5 问题：传递两个编码控制信号 解决方法1：产生一个ready信号(bden_n)来指示数据的有效性原文One potential solution to this problem, as shown in Figure 13, is to send a shaped enable signal to act as a “ready flag” in the new clock domain. The sending clock domain must generate and enable signal one clock cycle after asserting the decoder inputs. The sending clock domain must also remove the enable signal one clock cycle before de-asserting the decoder inputs. As described earlier, the enable signal must be asserted for a time period that is longer than the cycle time of the receiving clock domain. 译文第一种解决方法是发送一个经过整形的使能信号，这个信号在新时钟域中的作用就是一个“准备妥当标志位”。在编码输入信号置位后发送时钟域必须生成和使能一个时钟的信号。发送时钟域必须在输入信号复位前一个时钟移除使能信号。正如之前所提到的那样，使能信号必须置位一个时钟周期，并且这个时钟周期必须小于接收时钟域的一个时钟周期。 原文Under worst case conditions, the shaped enable signal will either be sampled at the same time as the encoded inputs are sampled into the receiving clock domain, or the shaped enable signal will be de-asserted at the same time as the encoded inputs are de-asserted in the receiving clock domain. Under best case conditions, the shaped enable pulse will be asserted one receiving clock cycle later than the assertion of the encoded inputs and de-asserted one receiving clock cycle before the de-assertion of the encoded inputs. This method insures that the encoded inputs are valid before they are enabled into the receiving clock domain. 译文在最坏的条件下，整形后的使能信号既不会在编码输入被接收时钟域采样的同时被采样到，也不会在编码输入在接收时钟域复位的同时而复位。在最好的情况下，整形后的使能信号会在编码输入置位的一个时钟后置位，并且在编码输入复位的一个时钟前复位。这种方法可以保证编码输入在接收时钟域使能前就有效了。 图6 解决方法1：产生一个ready信号(bden_n)来指示数据的有效性 解决方法2：使用one-hot key信号结合状态机来处理接收到的信号原文A second potential solution to this problem, as shown in Figure 14, is to decode the signals back in the sending clock domain and then send the decoded outputs (where only one of the outputs is asserted) through synchronizers into the new clock domain. Within the new clock domain, a state machine is used to determine when a new decoded output has been asserted. If there are no decoded outputs, it means that one decoded output has been de-asserted and that another decoded output is about to be asserted. If there are two asserted decoded output signals, the last decoded output signal will cause the state machine to change states and the older decoded output signal will turn off on the next rising clock edge in the new clock domain. It is important that the sender insure that the decoded outputs are each asserted for a time period that is longer than the cycle time of the receiving clock domain. 译文如下图显示，第二种解决这个问题的方法是在发送时钟域将信号进行编码，然后将编码后的信号（独热码）通过同步器发送到接收时钟域。新的时钟域中有一个状态机用来决定编码输出何时被置位。如果此时没有编码输出，这就意味着一个输出已经被复位了而另一个输出正准备置位。如果此时有两个编码输出置位，新的编码输出信号将导致状态机状态改变，而上一个编码输出信号将在新时钟域的下一个时钟上升沿复位。需要特别注意的是，发送端必须保证编码输出一次仅置位一个时钟周期，并且这个时钟周期不会比接收时钟域的一个时钟长。 原文Any time there are multiple control signals crossing clock boundaries, caution must be taken to insure that the sequencing of the control signals being passed is correct or that any potential mis-sequencing of the control signals will not adversely impact the correct operation of the design. 译文凡是在有多个控制信号跨越时钟边界的时候，控制信号必须保证时序正确，或者控制信号的任意潜在失序将不会影响这个设计的正确操作。 图6 解决方法2：使用one-hot key信号结合状态机来处理接收到的信号 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>异步时钟</tag>
        <tag>多信号同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Verilog 项目配置]]></title>
    <url>%2F2019-03-17%2Fhdl-prjsetting%2F</url>
    <content type="text"><![CDATA[根据以前的经验、书籍和网上的资料，自己总结了一个简单的项目设置，虽然做不到正规公司那么规范，但是尽自己可能地让自己做的设计更加完善，然后一步一步规范化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445project├── board #-存放不同电路板对应的配置文件│ ├── AX516│ └── PHASE2_R2│ ├── impact_bit.cmd #-用于下载bit文件的脚本│ ├── impact_mcs.cmd #-用于将bit文件转变成mcs文件的脚本│ ├── impact_spi.cmd #-用于下载mcs文件的脚本│ ├── top_sys.ucf #-PCB约束文件│ ├── top_sys.ut #-bit文件的设置参数│ └── top_sys.xst #-xst设置文件├── doc│ └── html #-doxygen生成的程序解释├── ipcore_dir #-ip存放的位置├── ise #-ise工程存放的文件夹，综合过程中生成的文件也将在这个文件夹里│ ├── clear.bat #-win下用于清理文件夹的批处理文件│ ├── comp.bat #-win下用于综合等的批处理文件│ └── Makefile #-用于综合，布局布线，生成bit，mcs并下载├── rtl #-工程源代码├── script #-常用脚本的备份│ ├── clear.bat│ ├── clearip.bat│ ├── msim.tcl│ ├── signal.rc│ ├── sim.bat│ ├── top_sys.prj│ ├── top_sys.ut│ └── top_sys.xst├── simpostsyn_ctrl_usb_com #-综合后仿真文件夹│ ├── filelist.f #-本次仿真的文件列表│ ├── Makefile #-将综合与仿真的过程结合在一起，节省很多时间│ ├── novas.rc #-verdi的配置文件│ └── signal.rc #-信号列表├── simrtl_ctrl_usb_com #-RTL仿真文件夹│ ├── filelist.f│ ├── Makefile│ ├── novas.rc│ └── signal.rc├── tb #-仿真所需要的顶层文件│ ├── tb_ctrl_usb_com.v│ └── tb_mdl_buf_mux.v└── tcdc #-chipscope配置文件│ └── chipscope.cdc├── shellX64.sh #-shell脚本，64bit├── shellX86.sh #-shell脚本，32bit└── readme.md #-工程简介文件]]></content>
      <categories>
        <category>强迫症专题</category>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>项目存档</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摩尔状态机和米勒状态机特性对比]]></title>
    <url>%2F2019-01-16%2Fmoore-mealy%2F</url>
    <content type="text"><![CDATA[之前对比过一段式，两段式和三段式状态机综合结果，在这个过程中发现大家对Moore状态机和Mealy状态机特别容易混淆。所以在这里专门写了这篇博文来详细介绍这些内容。 Moore状态机和Mealy状态机的对比下表以一个例子直观地对比了Moore状态机和Mealy状态机的异同，两者最大的区别在于状态机输出是否跟输入相关。 Moore状态机 Mealy状态机 Moore 状态机是时序逻辑输出只取决于当前状态的这一类状态机，其输出表达式为输出信号 = G(当前状态)。 Mealy 状态机是时序逻辑输出不但取决于状态，还取决于输入的一类状态机，其状态机输出表达式为输出信号 = G(当前状态，输入信号)。Moore 与 Mealy 状态机的互相转换根据哲学原理，讲完世界观就得讲方法论，讲完区别就得意识到事物之间是有普遍联系的，他们可以在一定条件下进行转化。状态机之间也不例外。 先讲Mealy-&gt;Moore的过程首先请出这次举例所需要的Mealy状态机，如下图： 这个状态机有三个状态：S0，S1和S2，仔细观察后不难发现指向S1的箭头有两种输出： 0和 1，指向S2的箭头也有两种输出：0和1，也就是说对于S1状态来说，状态机的输出并不仅仅与状态本身有关，还与状态机的输入有关，所以这是一个Mealy状态机。 接下来就是见证奇迹的时刻。高呼，汽车人，变形！哦，不，状态机，变形！ 第一步，先确定复位后的初始状态为S0，然后S0临近的两个状态分别为S1和S2。分别画上指向箭头，然后就存在了S0分别指向S1与S2的状态。如下图： 第二步，分析原状态机图，发现S1有两个输出，此时再使用一个状态就不太合适了，所以这时将S1拆分成两个状态：S10和S11，分别表示输出为0和1的两个状态；同理将S2也分解为S20与S21。如下图： 第三步， 在原始状态机中S1有指向S0的箭头，这两个转换过程的输出均为0，所以画两根箭头指向S0。如下图： 第四步， 参考第三步，S1在输入为0 时会指向S2，而且输出为1，所以这里画两根箭头指向S21。如下图： 第五步，在完成第四步的基础上画两根箭头由S20和S21指向S10。如下图： 锵锵，大功告成，Mealy状态机被完美改造成了Moore状态机。稍微做下整形： 再讲Moore-&gt;Mealy的过程Moore状态机转换成Mealy状态机的过程相对来说就要简单一些了。 下图是需要转换的Moore状态机。 第一步，观察状态机的组成，发现有两个状态机之间没有直接的联系，即这两个状态机之间没有箭头连接，他们就是A和D。然后观察到这两个状态机都有箭头指向状态B和状态C，所以这两个状态是可以融合的。 第二步，将A与D融合后产生新的状态AD’，同时，状态B和状态C就转变成新的状态B’和C’。然后在这个基础上进行调整和整理就得到了下面这张图。 Moore状态机与Mealy状态机的性能对比Mealy状态机Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849module top_sys ( input wire clk, input wire rst, input wire i, output reg out );reg [2:0] NS; //NextStatereg [2:0] CS; //CurrentStateparameter S0 = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= S0; else CS &lt;= NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) S0: begin if (i) begin NS &lt;= S2; end else begin NS &lt;= S1; end end S1: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S2; end end S2: NS &lt;= S1; default: NS &lt;= S0; endcaseend//3rd always block, the sequential FSM outputalways @ (*) begin case (CS) S0: out &lt;= 1'b0; S1: begin if (i) out &lt;= 1'b0; else out &lt;= 1'b1; end S2: begin if (i) out &lt;= 1'b0; else out &lt;= 1'b1; end default: out &lt;= 1'b0; endcaseendendmodule Synplify综合结果，682.2 MHz Moore状态机Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152module top_sys ( input wire clk, input wire rst, input wire i, output reg out );reg [3:0] NS; //NextStatereg [3:0] CS; //CurrentStateparameter S0 = 4'b0000;parameter S10 = 4'b0001;parameter S11 = 4'b0010;parameter S20 = 4'b0100;parameter S21 = 4'b1000;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= S0; else CS &lt;= NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) S0: begin if (i) begin NS &lt;= S20; end else begin NS &lt;= S11; end end S11: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S21; end end S10: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S21; end end S20: NS &lt;= S10; S21: NS &lt;= S10; default: NS &lt;= S0; endcaseend//3rd always block, the sequential FSM outputalways @ (*) begin case (CS) S0: out &lt;= 1'b0; S11: out &lt;= 1'b1; S10: out &lt;= 1'b0; S21: out &lt;= 1'b1; S20: out &lt;= 1'b0; default: out &lt;= 1'b0; endcaseendendmodule Synplify综合结果，614.3 MHz Moore vs Mealy 状态机这里对比了两种状态机的特点。 1. Mealy 机比 Moore 机 “响应” 速度快。 Mealy 机的输出与当前状态和输入有关，而 Moore 机输出仅与当前状态有关。Mealy 机的输入立即反应在当前周期；Moore 机的输入影响下一状态，通过下一状态影响输出。为此 Mealy 机比 Moore 机输出序列超前一个周期，即 “响应速度” 较快。Mealy 机的输出在当前周期，具有较长的路径（组合逻辑）；Moore 机的输出具有一个周期的延时，容易利用时钟同步，Moore 机具有较好的时序。 2. Mealy 机状态少，Moore 机结构简单。 由于 Moore 机的输出只有当前的状态有关，一个状态对应一个输出，Moore 机具有更多的状态。Mealy 和 Moore 机之间可以相互转化，对于每个 Mealy 机，都有一个等价的 Moore 机，Moore 机状态的上限为所对应的 Mealy 机状态的数量和输出数量的乘积。 3. 状态机的状态通过触发器的数量来反应，Mealy 机具有较少的状态，为此具有较少的触发器。 4. 血的教训告诉我，不能根据输出状态机的写法是否包含不同输入的不同输出而确定这是Mealy状态机还是Moore状态机。附录：有小伙伴表示对Graphviz生成的流程图比较感兴趣，所以在此处呈上两种状态机的Graphviz代码。 Mealy状态机123456789101112131415digraph fsm &#123; rankdir=LR; ratio=&quot;compress&quot; ranksep=1; size=&quot;8.0,8.0&quot;; node [fontsize=25]; node [shape = doublecircle]; S0; node [shape = circle]; &quot;S0&quot; -&gt; &quot;S1&quot; [label= &quot;0/1&quot;] &quot;S1&quot; -&gt; &quot;S0&quot; [label= &quot;1/0&quot;] &quot;S1&quot; -&gt; &quot;S2&quot; [label= &quot;0/1&quot;] &quot;S2&quot; -&gt; &quot;S1&quot; [label= &quot;x/0&quot;] &quot;S0&quot; -&gt; &quot;S2&quot; [label= &quot;1/0&quot;]&#125; 生成流程图如下： Moore状态机123456789101112131415digraph fsm &#123; rankdir=LR; ratio=&quot;compress&quot; ranksep=1; size=&quot;8.0,8.0&quot;; node [fontsize=25]; node [shape = doublecircle]; &quot;S0/0&quot;; node [shape = circle]; &quot;S0/0&quot; -&gt; &quot;S1/0&quot; [label= &quot;0&quot;] &quot;S1/0&quot; -&gt; &quot;S0/0&quot; [label= &quot;1&quot;] &quot;S1/0&quot; -&gt; &quot;S2/1&quot; [label= &quot;0&quot;] &quot;S2/1&quot; -&gt; &quot;S1/0&quot; [label= &quot;x&quot;] &quot;S0/0&quot; -&gt; &quot;S2/1&quot; [label= &quot;1&quot;]&#125; 生成流程图如下： 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Mealy to Moore and Moore to Mealy Transformation FSM 有限状态机 verilog三段式状态机设计实例（moore和mealy） 状态机的模型之Moore型状态机 状态机的模型之Mealy型状态机]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>有限状态机</tag>
        <tag>Moore</tag>
        <tag>Mealy</tag>
        <tag>状态机转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下边沿触发]]></title>
    <url>%2F2018-08-18%2Fup-down-edge%2F</url>
    <content type="text"><![CDATA[一般的资料都会建议不要将电路设计成上下边沿触发，同时一个系统中也尽量不要同时存在时钟上升沿触发和时钟下降沿触发，综合器在处理这类问题的时候会将时钟频率翻倍作为解决方案。 但是根据下面的综合结果发现，综合器会尽可能地把系统设计成单一时钟，而Altera的寄存器貌似支持相反时钟，而Xilinx的会直接根据真值表设计成相同时钟沿的。 同一模块时钟上升下降沿触发123456789101112131415161718192021222324252627282930module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data[0] &lt;= 1'b0; end else begin if (addr[0] == 1'b0) data[0] &lt;= 1'b1; else data[0] &lt;= 1'b0; endendalways@(negedge clk) begin if (rst) begin data[1] &lt;= 1'b0; end else begin if (addr[1] == 1'b0) data[1] &lt;= 1'b1; else data[1] &lt;= 1'b0; endendendmodule a) Quartus Cyclone IV E RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) Quartus Cyclone IV E Technological 原理图 d) Synplify Spartan6 Technological 原理图 同一模块时钟上升沿触发123456789101112131415161718192021222324252627282930module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data[0] &lt;= 1'b0; end else begin if (addr[0] == 1'b0) data[0] &lt;= 1'b1; else data[0] &lt;= 1'b0; endendalways@(posedge clk) begin if (rst) begin data[1] &lt;= 1'b0; end else begin if (addr[1] == 1'b0) data[1] &lt;= 1'b1; else data[1] &lt;= 1'b0; endendendmodule a) Quartus Cyclone IV E RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) Quartus Cyclone IV E Technological 原理图 d) Synplify Spartan6 Technological 原理图]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>Posedge Clock Edge</tag>
        <tag>Negedge Clock Edge</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的模块间交互的方法]]></title>
    <url>%2F2018-07-18%2Fmodel-interface%2F</url>
    <content type="text"><![CDATA[对系统的模块进行划分之后需要考虑的就是模块之间的信息交互，以下是我整理和总结的常见结构，在这些结构的基础上再根据实际情况进行调整。这篇笔记中的交互方法是针对同步时钟模块进行介绍的，异步时钟模块的使用需要略微调整。 直接交互直接交互不需要接收端反馈，发送端直接发送数据，一般用于下游模块的处理速度快于上游模块的数据发送速度。框图如下图： 典型案例举例：包文汇聚模块，系统框图如下： 此项目中网口A的时钟是40MHz，网口B的时钟是20MHz，网口C的时钟是10MHz，下游模块的工作时钟是80MHz。由于下游模块的处理速度高于上游模块的总发送速录，所以即使三个网口同时发送数据，下游模块任可以完成对所有数据的处理。 因此，下游模块不需要通过反馈信号控制上游模块数据的发送，即采用直接交互架构即可。 rdy交互无缓存rdy交互当rdy为高电平时，表示模块B可以接受模块A的读写命令，开始传输数据，模块A每发送一个数据，模块B就处理，处理完后再发送下一个数据。一般应用于上游模块速率高，下游模块速率低，并且上游模块有缓存的场景。框图如下图。 有缓存rdy交互收到读写命令后，模块A开始传输数据，数据先输入模块B的FIFO，然后模块A和模块B按照各自时钟进行读写FIFO的数据，可以解决读写速率不匹配的问题。一般应用于上下游模块都有缓存的场景。优点是控制简单，对时序要求不太严格。框图如下图。 应答交互模块A请求发送，模块B收到应答后就可以传输数据。一般应用于上游模块等待响应后才能连续发送一段数据的场景。框图如下图: 全握手全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路A声明它的请求信号，然后接收方电路B检测到该请求有效后，声明它的效应信号；当电路A检测到响应信号有效之后，中止自己的请求信号；最后，当电路B检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非A检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路A必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。 全握手鲁棒性很好，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。时序图如下： Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081module top_sys ( input wire clk, input wire rst, input wire trig );reg req;reg ack;reg data;reg [3:0] req_idx;reg [3:0] ack_idx;always @(posedge clk or posedge rst) begin if (rst) begin req_idx &lt;= 4'd0; req &lt;= 1'b0; end else begin case (req_idx) 4'd0: begin if (trig == 1'b1) begin req &lt;= 1'b1; req_idx &lt;= 4'd1; end else begin req &lt;= 1'b0; req_idx &lt;= 4'd0; end end 4'd1: begin if (ack == 1'b1) req_idx &lt;= 4'd2; else req_idx &lt;= 4'd1; end 4'd2: begin req &lt;= 1'b0; req_idx &lt;= 4'd3; end 4'd3: begin if (ack == 1'b0) begin req &lt;= 1'b0; req_idx &lt;= 4'd4; end else req_idx &lt;= 4'd3; end 4'd4: begin req_idx &lt;= 4'd4; end endcase endendalways @(posedge clk or posedge rst) begin if (rst) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end else begin case (ack_idx) 4'd0: begin if (req == 1'b1) begin ack &lt;= 1'b1; ack_idx &lt;= 4'd1; end else begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end end 4'd1: begin if (req == 1'b0) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd2; end else ack_idx &lt;= 4'd1; end 4'd2: begin ack_idx &lt;= 4'd2; end endcase endendendmodule PS：这里留个记号，仿真中明明4个时钟就可以了，为什么资料中显示这里需要5个时钟呢？ 部分握手1部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。在第一种握手方法中，电路A以有效电平声明其请求信号，电路B以一个单时钟宽度脉冲作为响应。此时，电路B并不关心电路A何时中止它的请求。省去了完整握手流程里面的最后一步，也就是ack信号自动会把自己复位，而不是要等检测到req信号复位之后了。时序图如下： 部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module top_sys ( input wire clk, input wire rst, input wire trig );reg req;reg ack;reg data;reg [3:0] req_idx;reg [3:0] ack_idx;always @(posedge clk or posedge rst) begin if (rst) begin req_idx &lt;= 4'd0; req &lt;= 1'b0; end else begin case (req_idx) 4'd0: begin if (trig == 1'b1) begin req &lt;= 1'b1; req_idx &lt;= 4'd1; end else begin req &lt;= 1'b0; req_idx &lt;= 4'd0; end end 4'd1: begin if (ack == 1'b1) begin req_idx &lt;= 4'd2; end else begin req_idx &lt;= 4'd1; end end 4'd2: begin req &lt;= 1'b0; req_idx &lt;= 4'd2; end endcase endendalways @(posedge clk or posedge rst) begin if (rst) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end else begin case (ack_idx) 4'd0: begin if (req == 1'b1) begin ack &lt;= 1'b1; ack_idx &lt;= 4'd1; end else begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end end 4'd1: begin ack &lt;= 1'b0; ack_idx &lt;= 4'd2; end 4'd2: begin ack_idx &lt;= 4'd2; end endcase endendendmodule 部分握手1仿真总共占用3个时钟。 部分握手2电路A使用一个单时钟宽度脉冲发出它的请求，电路B也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。省去了完整握手流程里面的最后两步，两个信号在置位保持一段时间以后都是自动复位，不在相互检测。时序图如下： Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162module top_sys ( input wire clk, input wire rst, input wire trig );reg req;reg ack;reg data;reg [3:0] req_idx;reg [3:0] ack_idx;always @(posedge clk or posedge rst) begin if (rst) begin req_idx &lt;= 4'd0; req &lt;= 1'b0; end else begin case (req_idx) 4'd0: begin if (trig == 1'b1) begin req &lt;= 1'b1; req_idx &lt;= 4'd1; end else begin req &lt;= 1'b0; req_idx &lt;= 4'd0; end end 4'd1: begin req &lt;= 1'b0; req_idx &lt;= 4'd1; end endcase endendalways @(posedge clk or posedge rst) begin if (rst) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end else begin case (ack_idx) 4'd0: begin if (req == 1'b1) begin ack &lt;= 1'b1; ack_idx &lt;= 4'd1; end else begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end end 4'd1: begin ack &lt;= 1'b0; ack_idx &lt;= 4'd2; end 4'd2: begin ack_idx &lt;= 4'd2; end endcase endendendmodule 部分握手2仿真总共占用2个时钟 异步时钟特别篇异步全握手时序图： 握手图解： 这种类型的握手使用了电平同步器。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端A需要 5 个周期，接收端B需要 6 个周期。 异步部分握手1时序图： 握手图解： 为了让这种部分握手1方法成立，电路A中止请求信号至少要 1 个时钟周期长度，否则，电路B就不能区别前一个和后一个新的请求。在这种握手方式下，电路B为请求信号使用一个电平同步器；电路A为响应信号使用一个脉冲同步器。只有当电路B检测到请求信号时才发出响应脉冲，这样电路A控制请求信号的时序，就能控制自己同步器接收到的脉冲间隔。同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路A需要花费 3 个时钟周期，接收端B需要花费 5 个时钟周期。 异步部分握手2时序图： 握手图解： 这种握手使用的是脉冲同步器。完整的时序是：电路A需要花费 2 个时钟周期，电路B需要花费 3 个时钟周期。 异步时钟握手总结 因为握手内部采用了同步器，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的同步器和握手信号，就有了前面介绍的 3 种不同的握手方式： 全握手是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。 部分握手是对全握手的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的部分握手。 部分握手1精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了1次半的握手。而且修改了全握手中电平握手的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路A则必须使用脉冲同步器来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的同步器，部分握手1就比全握手方式节约了很多时间。 部分握手2则更进一步，在部分握手1的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成1次握手。而且两部分电路的同步器同时修改为脉冲方式。这样子进一步减少了握手花费的时间。 部分握手和全握手的本质区别不在于同步器的类型和握手信号的多少，而在于握手的方式。 部分握手不用再等待对方的回答，就继续进行自己的下一步操作，而全握手必须等到对方的回复才进行下一步的操作，所以从某种意义上，全握手方式才是真正的“握手”，而部分握手并不符合 “握手” 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 跨越鸿沟：同步世界中的异步信号 cpu与fpga跨时钟域数据交换的实现问题 FPGA 时钟设计 3 —— 跨时钟域设计 跨时钟域设计的一点总结 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>异步时钟</tag>
        <tag>模块交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FPGA 复位研究]]></title>
    <url>%2F2018-07-18%2Ffpga-reset%2F</url>
    <content type="text"><![CDATA[初学FPGA的时候对FPGA的理解最多停留在always@阶段，后来有次跟同事讨论FPGA的复位问题，她在一次DEBUG的过程中怀疑FPGA复位不完全，我对此表示不理解，原因是我对FPGA复位的理解不一样：FPGA的复位不像MCU的，它本身是没有复位这种功能的，在FPGA中reset是电路，也就是说你按下reset的按键也只是触发程序中的if(rst)这部分。在这里我打算总结一下复位相关的内容。 复位根据高低电平复位可分为高电平复位和低电平复位目前大多数文章和博客都推荐使用低电平复位，但是没人会告诉你为啥用低电平复位，我在网上找到的一些资料给出的理由无非是如下三种： 1. ASIC设计大多使用低电平复位； 2. 大部分厂家的FPGA使用低电平复位； 3. 低电平复位方式，系统上电时就处于复位状态；关于第二点我有话要说，我不赞成第二种观点，下图是两种器件同步高电平复位的综合结果： 对于Xilinx器件，Spartan6默认的寄存器主要是高电平复位，在ISE的综合结果中，RTL代码使用低电平复位，但是综合后的网表中都会插入一个反相器，而插入反相器会增加组合逻辑电路，组合逻辑电路的增加会导致传输延时增加，进而芯片利用率增加，同时会影响时序和功耗。 如果处于代码复用等考虑而要使用低电平复位，那么可以在系统顶层将复位极性翻转，这样综合器在进行综合的时候会将反相器吸收到IO logic中，不会消耗FPGA内的逻辑和布线资源。 a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 c) Altera Cyclone IV E RTL 原理图 d) Altera Cyclone IV E Technological 原理图 下图是在Cyclone IV E中布局布线之后的结果，对于Altera的器件，Cyclone IV E的寄存器并没有异步复位端，那么使用同步复位的话，综合器会将复位信号综合为输入信号的数据选择信号，这时候就需要额外的逻辑资源了。 To do list： [ ] 1. 芯片利用率受复位反相器添加影响程度到底是多少？之后将进一步尝试。 [ ] 2. 最好有同步复位与异步复位的原理对比 复位根据是否同步可以分为同步复位和异步复位同步复位和异步复位各有优缺点，待我娓娓道来： 同步复位Code： 12345678910111213141516module top_sys ( input wire clk, input wire rst, input wire d, output reg q );always@(posedge clk) begin if (rst) begin q &lt;= 1'b0; end else begin q &lt;= d; endendendmodule a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 c) Altera Cyclone IV E RTL 原理图 d) Altera Cyclone IV E Technological 原理图 优点：1 设计是完全同步，有利于时序分析； 2 因为是完全同步，所以可以降低亚稳态出现的几率； 3 在某些设计中（例如使用锁相环的lock管脚作为），复位信号由内部逻辑产生，推荐使用同步复位，这样可以避免逻辑电路产生毛刺。 缺点：1 不是所有的ASIC库都带有同步复位寄存器，但是这个并不严重，因为同步复位信号只是另一个数据的输入信号，所以综合工具容易把复位信号综合到寄存器外部的逻辑电路中。（待验证） 2 同步复位需要保证复位信号具有一定的脉冲宽度，这点对于系统异步控制产生的复位信号格外重要，例如150MHz模块产生的复位信号输入到50MHz的模块，这点就需要设计同步模块。 3 在仿真中，对于一些基于逻辑表达式计算的仿真器上，一些逻辑可能会阻止复位信号作用到寄存器上。但这是只存在于仿真器的问题，硬件上没有问题。（待验证） 4 同步复位需要时钟处于正常工作状态，这在某些场合就可能有问题，例如：为了降低功耗而选择门控时钟作为模块的控制时钟，在休眠中系统时钟并不工作，若此时同步复位有效，而时钟恢复后复位信号撤销了，那么系统将不能复位。 5 如果设计中含有三态总线，为防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位。（待验证） 6 如果逻辑前进的目标库只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。网上流传的“同步复位会产生额外的逻辑资源”也许指的就是基于Altera的FPGA进行的设计，如下： 但是对于Xilinx的器件，例如我在Spartan6和Zynq7上的实测结果，原语里面已经包含带同步或异步复位的寄存器，所以综合出来的电路并没有“产生额外的逻辑资源消耗”。所以说是否产生额外的逻辑资源消耗关键在于选择怎样的设备，具体问题还要具体分析。 7 类似于时钟信号，复位信号是高扇出信号，最好要加上buffer，一旦复位信号进入到局部逻辑区域，那么就得要限制复位信号到达寄存器所经历的逻辑数量，以减少延迟。 异步复位Code： 12345678910111213141516module reset_async ( input wire clk, input wire rst, input wire d, output reg q );always@(posedge clk or posedge rst) begin if (rst) begin q &lt;= 1'b0; end else begin q &lt;= d; endendendmodule a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 c) Altera Cyclone IV E RTL 原理图 d) Altera Cyclone IV E Technological 原理图 优点：1 几乎所有的库中都包含异步复位寄存器，所以异步复位最大的优点是不需要额外逻辑资源，可以保持数据路径干净，这在数据路径时序紧张时比较管用； 2 脉冲宽度没有限制； 3 没有时钟的时候也可以复位，例如门空电路； 4 EDA工具route起来更容易，对于大型设计能显著减少编译时间；（待验证） 缺点：1 异步电路不利于时序分析，要正确约束异步复位信号比同步复位信号更加复杂；（待验证） 2 异步信号容易受到毛刺的干扰，异步复位信号也一样，系统的毛刺可能产生复位误操作； 3 异步信号最大的问题是复位信号如果产生亚稳态问题，可能导致系统一直无法完成复位；网上的一种说法如下：异步复位最大的问题是容易在复位信号的起效（assert）和失效（deassert）是异步的，起效异步没有问题，但是失效异步可能导致亚稳态。(撤销的时候(release)不满足 removal time 时序要求，从而产生亚稳态)（暂时没太看懂这段，待验证） 对比同步复位电路和异步复位电路的实际结果其实光讲同步复位和异步复位估计大家都不太理解两者的差别，所以我试了一下两者的对比： 仿真波形如下： q1是同步复位电路的输出信号，q2是异步复位电路的输出信号。 1 q1的跳变都发生在时钟上升沿，如2，3所示。 2 q2的复位发生在rst的置位端，如1，4所示；只有当3处在时钟上升沿且复位信号复位的时候，q2才会置位。 所以在drv置位时，输出置位会随着clk信号的上升沿变化；而异步触发器低电平有效，只要rst信号由高变低，输出信号立刻改变，所以信号并未跟着clk信号对齐。 异步复位，同步触发各种复位虽然有各自的优缺点，但是设计过程永远是“两权相害取其轻”，目前很多文章中推荐的大都是一种“异步复位，同步释放”的方法，这种方法可以将两者的优点结合起来。 原理如下所示： 使用打两拍的方式来进行同步 Code： 12345678910111213141516171819202122module SYNC_RST ( input wire clk, input wire rst_pb, output reg sys_rst );reg rst_r;always @ (posedge clk or negedge rst_pb) begin if (!rst_pb) rst_r &lt;= 1'b1; else rst_r &lt;= 1'b0;endalways @ (posedge clk or negedge rst_pb) begin if (!rst_pb) sys_rst &lt;= 1'b1; else sys_rst &lt;= rst_r;endendmodule 综合后的电路图： 关于这个异步处理的方法和优点，请参考另外两篇博文： 1 异步时钟信号同步化及其综合结果 2 亚稳态的产生和对应策略 结论1. 尽可能使用同步复位，保持设计的“同步化”； 2. 如果器件本身带有同步复位端口，那么直接使用同步复位，Xilinx就是个典型案例； 3. 如果不带同步复位，那么使用异步复位时必须包含同步器。在详细讨论了各种复位方式之后接下来将介绍一些使用过程中常遇到的场景 不适合复位的场景组合逻辑电路组合逻辑电路不要加上复位，因为组合逻辑电路本身是没有“记忆”这种特性的，也就是说不需要复位的过程来让其“失忆”。如下实验，综合器在综合的过程中将rst信号综合进了输入信号，最终成为了数据选择器。 Code： 12345678910111213141516module reset_sync ( input wire clk, input wire rst, input wire d, output reg q );always@(*) begin if (rst) begin q &lt;= 1'b0; end else begin q &lt;= d; endendendmodule a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 移位寄存器不是所有的寄存器都需要复位。移位寄存器就是一个典型的例子，移位寄存器只需要复位第一个寄存器，后续的触发器仅作为数据寄存器使用。这里体现的一个原则就是：reset能省则省。因为reset往往跟clk同时出现，但是FPGA中有时钟树用于时钟优化，但是没有复位树优化复位信号（待查？？是否有reset distribution tree），所以对于拥有大量扇出的reset信号，很容易造成route难度上升，性能下降，编译时间增加。 比较好的设计风格，不同类型的寄存器不应该组合进同一个always块，最好的风格应该是只对一种寄存器建模。 不好的代码风格Code： 12345678always @(posedge clk) begin if (rst) begin tmp &lt;= 1'b0; end else begin tmp &lt;= d; q &lt;= tmp; endend 综合后的原理图： a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 复位信号对于第二个寄存器来说是一个片选信号，rst在这里有两个扇出。 好的代码风格Code： 12345678910111213141516171819module good_codestyle ( input wire clk, input wire rst, input wire d, output reg q );reg tmp;always @(posedge clk) begin if (rst) begin tmp &lt;= 1'b0; end else begin tmp &lt;= d; endendalways @(posedge clk) begin q &lt;= tmp;endendmodule 综合后的原理图： a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 复位信号与第二个寄存器没有连接，可以看到第二个寄存器减少了一个扇出信号。 多时钟复位在一个系统中，往往有多个时钟，每个时钟域都应该有独立的同步器和复位，如果使用系统复位，各时钟域复位与系统复位的关系就为异步复位，而异步复位可能导致的亚稳态问题会对系统的稳定性造成影响。 全局同步复位对于大多数多时钟域系统，不同时钟域之间的复位信号并没有先后要求，尤其是在request-acknowledge这样的握手信号系统中，不会引起硬件上的误操作，这时候全局同步复位即可。 How do I reset my FPGA 在文中提供了一张图来说明典型的系统复位方案，图中 MMCM 的 lock 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。 顺序复位对于部分对复位有要求的设计，复位信号的释放顺序有一定的要求，此时要使用如下的方法： 复位毛刺滤波异步复位系统对毛刺比较敏感，下图是一种系统中处理毛刺的方法，简单粗暴，但是据说比较丑陋？！(时延不是固定的，会随温度、电压变化) 需要注意的是 1. 毛刺 Glitch 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论见《锁存器与竞争冒险》 2. 不是所有的系统都需要过滤毛刺，设计者要先研究需求，再觉得是否使用延时来过滤毛刺总结1. 复位方式应该根据具体使用哪种器件决定，Xillinx推荐使用高电平复位，Altera的器件推荐使用低电平复位； 2. 尽可能使用同步复位，保持设计同步化，如果器件本身带有同步复位，请直接在RTL代码中使用同步复位，如果器件不带同步复位端口，那么就需要一部复位同步化； 3. 每个时钟域都应该有一个同步器来同步复位信号；参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use? Asynchronous &amp; Synchronous Reset Design Techniques - Part Deux Get Smart About Reset: Think Local, Not Global How do I reset my FPGA FPGA复位电路的实现及其时序分析 深入浅出玩转 FPGA 100 Power Tips for FPGA Designers Advanced FPGA Design by Steve Kilts FPGA 的复位 Asynchronous reset synchronization and distribution Special cases FPGA 中的复位设计]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>异步时钟</tag>
        <tag>电平同步</tag>
        <tag>复位</tag>
        <tag>器件特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步时钟信号同步化及其综合结果]]></title>
    <url>%2F2018-07-16%2Fasync-clock-sync%2F</url>
    <content type="text"><![CDATA[异步时钟处理是每个使用FPGA的工程师都必须要掌握的技巧。可以说，如果你不会处理异步时钟信号，那么我会认为你压根儿就没用过FPGA。这里总结了三种常见的异步时钟处理方法，并且在仿真中验证过。 通常使用 MTBF (Mean Time Between Failures) 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×10^9 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。 理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。 如图所示： 图1 同步器结构 通常，同步器由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。 为了让同步器正常工作，从某个时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入同步器。之所以这样要求，是因为同步器的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过同步器，给新时钟域后续逻辑一个虚假的信号。 同步器有很多设计方法，因为一种方法不能满足所有的应用需求。同步器的类型基本上分为 3 种： 1. 电平同步器 2. 边沿检测同步器 3. 脉冲同步器下面分别讨论： 电平同步器Schematic: 图2 电平同步器结构 电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 paper 中有更详细的图解说明： 图3 电平同步器详细介绍 Code:123456789101112131415161718192021222324252627282930module LVLSYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output reg dat_dst );// source time domainreg dat;always @(posedge clk_src) begin if (rst_src) begin dat &lt;= 1'b0; end else begin dat &lt;= dat_src; endend// destination time domainreg dat_r;// using two level DFF to synchronize the din_qalways @(posedge clk_dst) begin if (rst_dst) begin dat_r &lt;= 1'b0; dat_dst &lt;= 1'b0; end else begin dat_r &lt;= dat; dat_dst &lt;= dat_r; endendendmodule RTL: 图4 电平同步器RTL图 SIM: 图5 电平同步器仿真图 Restriction:使用电平同步器的要求是： 1. 源时钟域的信号应先通过源时钟域的一个 DFF 后输出，然后直接进入目的时钟域的同步器的第一级 DFF。这么做到原因是：同步器的第一级 DFF 对组合逻辑产生的毛刺（glitch）非常敏感。如果一个足够长的毛刺刚好满足了 setup/hold time，那么同步器会将其放行，产生一个虚假的信号。 2. 跨域时钟域的这个信号持续时间 &gt;= 2 个新时钟域时钟周期。虽然 Crossing the abyss: asynchronous signals in a synchronous world 中是这么写的，但是我觉得这个条件应该是保险条件，而不是最低条件。 电平同步器的最低条件应该和边沿检测同步器相同： 输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。 首先，待同步到信号宽度 &gt; 源时钟周期，这样它才能被源时钟域的 DFF 采样到，然后输出； 其次，源时钟域采样输出端信号的宽度当然是源时钟周期的整数倍，它的宽度 &gt; 目标时钟域周期 + 第一个 flip-flop 的 hold time，这样它才能被目的时钟域的时钟采样到，然后进行同步。 所以，保险一点的条件是：待同步到信号有效时间至少是目的时钟周期的 2 倍。电平同步器是其他两种同步器的基础： 边沿检测同步器边沿检测同步器 是在电平同步器的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。 Schematic: 图6 边沿检测同步器结构 Code:123456789101112131415161718192021222324252627282930module EDGESYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output wire dat_dst );// source time domainreg dat;always @(posedge clk_src) begin if (rst_src) begin dat &lt;= 1'b0; end else begin dat &lt;= dat_src; endend// destination time domainreg [2:0] sync_reg;always @(posedge clk_dst) begin if (rst_dst) begin sync_reg &lt;= 3'b0; end else begin sync_reg &lt;= &#123;sync_reg[1:0], dat&#125;; endend// AND to get the outputassign dat_dst = sync_reg[1] &amp;&amp; (~sync_reg[2]);endmodule RTL: 图7 边沿检测同步器RTL图 ###SIM: 图8 边沿检测同步器仿真图 Restriction:使用边沿检测同步器的要求是： 1. 输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。实际上，因为在源时钟域，要先用 DFF 寄存一下再输出，所以源时钟域输出的信号的宽度是其时钟周期的整数倍，它肯定是 &gt; 目标时钟周期的，因为边沿检测同步器只能工作在慢时钟域到快时钟域的情况下。边沿检测同步器在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用脉冲同步器。 脉冲同步器脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。源时钟域的单时钟宽度的脉冲不是直接输出的，而是先经过一个源时钟域的翻转电路。这个翻转电路在每次输入一个脉冲时，它的输出会在高、低电平之间翻转。而在目的时钟域，翻转电路的输出先通过一个电平同步器，其输出到达异或门的一个输入端，而这个输出再经过一个 DFF，延时一个时钟周期后进入异或门的另外一个输入端。最后异或门的输出即最终的同步结果：源时钟域每有一个单时钟脉冲（源时钟），同步器的输出端产生一个单时钟宽度（目的时钟）的脉冲。 Schematic: 图9 脉冲同步器结构图 Code:123456789101112131415161718192021222324252627282930313233module EDGESYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output wire dat_dst );// source time domainreg toggle_reg;always @(posedge clk_src or posedge rst_src) begin if (rst_src) begin toggle_reg &lt;= 1'b0; end else begin if (dat_src) begin toggle_reg &lt;= ~toggle_reg; end endend// destination time domainreg [2:0] sync_reg;always @(posedge clk_dst) begin if (rst_dst) begin sync_reg &lt;= 3'b0; end else begin sync_reg &lt;= &#123;sync_reg[1:0], toggle_reg&#125;; endend// XOR to generate the pusle_dstassign dat_dst = sync_reg[1] ^ sync_reg[2];endmodule RTL: 图10 脉冲同步器RTL图 SIM： 图11 脉冲同步器仿真图 Restriction:使用脉冲同步器的要求是： 1. 输入脉冲之间的最小间隔 &gt;= 2 个同步时钟周期。如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻，形成一个比单时钟周期宽的输出脉冲。 实际上，在一些情况下，少于 2 个时钟周期（&gt; 1 个时钟周期）也是可以同步上的。只要同步器的两个 DFF 的值不一样即可同步上，也就是说异步信号在连续的两个目的时钟采样的值不同即可，由于异步信号和时钟的相位关系不确定，所以在没有对齐的情况下，大于 1 个时钟时也能满足两个采样值不同的条件。 一般为了保险起见，要求其保持至少两个时钟宽度。时钟消耗同步器需要花费 1～2 个时钟周期来完成同步，所以粗略的估计可以认为同步器会造成目的时钟域的 2 个周期的延迟，我们在设计时需要考虑同步器对时序产生的影响。 总结总结3种同步器的特点，有下表： 图12 三种同步器的优缺点比较 虽然还有其他类型的同步器，但是这 3 种基本上就可以解决设计中遇到的多数问题了。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 跨越鸿沟：同步世界中的异步信号 cpu与fpga跨时钟域数据交换的实现问题 FPGA 时钟设计 3 —— 跨时钟域设计 跨时钟域设计的一点总结 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>异步时钟</tag>
        <tag>电平同步</tag>
        <tag>边沿检测同步</tag>
        <tag>脉冲同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wire and Reg等定义的综合结果]]></title>
    <url>%2F2018-05-04%2Fwire-reg%2F</url>
    <content type="text"><![CDATA[在我刚开始使用ISE的时候，阻塞赋值和非阻塞复制让我头疼了很久，倒不是不理解这两种赋值方式，而是不理解组合逻辑电路和时序逻辑电路的设计本质。今天来稍微总结一下： reg型凡是在always块中进行赋值，变量一定得要是reg型，但是这并不意味着所有用reg的变量一定会综合成时序逻辑电路。比如： 12345678910always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; endend 1234567always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default: data &lt;= 2'b10; endcaseend 这里的两段代码中data都被定义为reg，但是综合结果却完全不一样，第一段代码会综合成时序逻辑电路，data会综合成FF，第二段代码会综合成组合逻辑电路，data会被综合成导线。 wire型而assign语句只能使用wire型进行赋值： 12345678910module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output wire [1:0] data );assign data = addr + rst;endmodule PS：同样在always@（*）块中，ISE会对 data=2’b00 语法报错，而Quartus不会报错，这点需要注意！]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>变量定义</tag>
        <tag>Wire</tag>
        <tag>Reg</tag>
        <tag>实际电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程存档文件夹命名]]></title>
    <url>%2F2017-08-13%2Ffolder-manage%2F</url>
    <content type="text"><![CDATA[对于我这种强迫症，工程管理都做了，那怎么能不顺便做一下文件夹的命名管理呢？奸笑 我的工程文件夹使用扁平化的存放形式，那是因为我不喜欢文件夹套文件夹的存放方式，一级地找文件就像是在迷宫中找出口一样复杂。 AA_Buf: 临时存放，之后需要整理 BB开头的文件夹代表上位机软件相关(binary的简称)： BT开头的文件夹代表已编译的可执行文件 T代表Tool BXX代表含源码的工程，B后的两位代表编程语言，例如BCC就是使用C语言的工程 #由于编程语言较多，程序语言使用双字编码，其中： CC：C语言； CS: C#； CP: C++； VR: Verilog ； VH: VHDL UU: 不确定 JS: Json JV：JAVA VB：Visual Basic； BT:批处理指令； MT：Matlab； JS:Jason； CP:Citespace; BXXR代表含源码的参考工程，注释同上 BSYS代表操作系统 PET:petalinux； AND：安卓； UBN：Ubuntu 后面加上版本号，例如： BSYS_PET_1704_FullBioSignal_Phase2CC开头文件夹代表结构设计相关： 第二个字母代表模型格式 S: SOLIDWORKS; C: CREO; A: AUTOCAD的DWG,DXF文件； D: PDF; T: STEP 同一个文件夹中若同时包含几种模型格式，则按照SAC顺序排序 第三个字母代表模型用途 R:参考设计（Reference）； D：草稿（Draft）； L：库（Library）； E：PCB模型，用于和结构工程师交互； S：仿真（Simulation）。 第四个字母代表模型库的细分类 P:泵（PUMP）； V:阀（Valve）； J:接头（Junction）EE开头的文件夹代表PCB工程 EX_板号_XXX_RX 电子设计的工程文件,尾缀是版本号，R是状态，R代表原型设计，D代表设计 EXL_XXX 某个项目的临时库 EXR_XXX 电子设计的参考设计 其中，使用一个字母表示文件格式： C:Cadence； A：Altium； P：PADS； D：PDF； E：Eagle； X：EE； G：GERBER 如果有多个文件的，按照CAPDEXG的顺序取第一个字母。FF开头的文件夹代表固件相关(firmware的简称)： FXX代表含源码的工程，F后的两位代表编程语言，但是之后需要加上主芯片和IDE的代号. 例如FCC_430_I_XXXX就是使用C语言的工程，主芯片为430，IDE为IAR Xilinx ： SP7：Spartan-7； AX7：Artix-7； ZQ7：Zynq-7； KX7：Kintex-7； Altera： AA10：Arria-10； MX10：Max-10； SR10：Stratix-10； CY10：Cyclon-10. #由于编程语言较多，程序语言使用双字编码，其中： CC：C语言； CP: C++； VR: Verilog ； VH: VHDL UU: 不确定 #IDE代码： I: IAR K: KEIL C: CREATER A: ANDES H: HOLTEK U: 无IDE S: SILICON STUDIO V: VIVADO Q: QuartusII S: ISE 如果有多个IDE的，按照KIUCHAS顺序排序 FXXR代表含源码的参考工程，注释同上 FXXL_MAIN-IC_LIB_VERSION 存放官方的库文件，例如STM32和EFM32的库，但是TI提供的却只是例程，不算是库。 另外，我自己写BSP暂时不进行归档处理，因为各种硬件差别比较大，所以也没必要做通用适配，等要用到的时候再复制即可。RR开头的文件夹代表网上下载的资料文件(reference的简称)： R后面可以有第二个字母用来对内容进行细分,比如： RD开头的文件夹代表设计思路相关(design的简称)： RP开头的文件代表有详细文件的参考工程 RC开头的文件夹代表结构参考工程 RCX_开头的文件夹代表某大类结构件相关规格书，例如RCP代表的就是泵,其中: P: 泵； V: 阀； RE开头的文件夹代表电子相关资料： REX_开头的文件夹代表某大类电路元器件, 例如REC代表的就是电容 细分类同原理图库 规格书格式 厂家名_型号_功能描述 RS开头的文件夹代表仿真相关资料 RSX_开头的文件夹代表相应工具的参考资料，例如RSC代表的就是PSPICE的相关资料,其中: C：Cadence（Pspice）； S：Saber；MM开头的文件夹代表生产相关的文件，需要特别注意别弄混 M_XXX 指向的是某个项目的具体加工或报价或采购记录，内容可以考虑用压缩包的形式样品采购文件夹存放采购相关信息，主要是单独物料采购，供货商的样品采购。 一定要加上供货商的详细信息。SS开头的文件夹代表仿真相关文件，仿真用的文件，特别需要注意删除一些不是很重要的仿真结果，免得占地方,不需要在所有客户端都进行同步，这些可以使用Git进行管理 第二个字母代表仿真内容： C：结构； E：电子相关； H：热力学仿真 第三个字母代表仿真工具 A：ANSYS相关软件； C：Cadence； L：LTSPICE； S:Saber； M：Comsol； T:TINA 第四个字母L代表相关软件的库TT开头的文件夹代表测试数据，测试报告等文件，不需要在所有客户端都进行同步 T_WM_XXXXXX_具体内容 实验数据和实验报告的命名方式可能还得再考虑考虑 图片类的实验数据要写明是做什么用的VV开头的文件夹存放音频和视屏文件，用于存放极其重要的音视频文件，这个比较占地方，需要及其注意 ZzRubbish文件夹用来存放没什么用可以删掉的资料 最后来一张效果图：]]></content>
      <categories>
        <category>强迫症专题</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>工程存档</tag>
        <tag>扁平化命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git管理工程的方法]]></title>
    <url>%2F2017-08-07%2Fuse-git%2F</url>
    <content type="text"><![CDATA[Git是当下最流行的工程管理方法，作为一个硬件工程师，也得要跟上时代的脚步，努力学习其他行业的技术优点。在了解了Git之后，发现它是当之无愧的神器，用Git就是爽，一直Git一直爽！ 首先讲一下为啥要用Git 不使用Git 使用Git Git特别适合代码这种试错成本低，迭代快速，带有尝试性质的场合。 简单讲一下Git， Github，SVN之间的联系与区别Git和SVN都是一种文件管理方式：Git是基于分布式库管理设计的，在本机上会有一个仓库，同时，也可以在云端有一个仓库，所以没有服务器端其实也可以提交和版本备注；SVN是集中式管理的，仓库直接上传到服务器端，没有服务器端就基本上用不了。GitHub是众多基于Git技术的管理服务器端之一，他们做的基于Git的客户端工具叫做GitHub-Desktop。此外，还有Sourcetree，GitKraken等。 所以，正确的层次结构应该是这样的： 项目管理技术服务器客户端 GitGitHubGitHub-Desktop AtlassianSourceTree GitKrakenGitKraken GitLab无 无TortoiseGit 无Git（Git原生的客户端） SVN没了解过没了解过 PS： 1. 以前免费版的GitHub账户只能创建公开仓库，自从巨硬收购了GitHub后，现在免费版账户也能创建私有账户了。 2. Git的项目文件夹可以用上述任何一款客户端打开和编辑，他们是标准格式，不会有冲突。 3. 虽然有些Git客户端会自带Git控制台，但是不建议把这种Git控制台用作全局使用，因为他们的路径名称中有软件自己的名字和版本号，更新几次后会导致路径名失效。实验室用群晖搭建了GitLab，接下来就让咱们来试用一下吧 准备工作：1.git客户端1.产生gitlab服务端和本地git相互传输时所需要校验的私钥和公钥 2.直接在Idea中使用git提交和push代码，当然也可以用sourcetree提交代码 2.sourcetree客户端1.拉取远端服务器代码到本地 2.push本地代码到远端 3.创建分支，解决提交代码中的冲突 3.gitlab账号（一般公司配置，用自己的邮箱）1.建立远端分支，可追踪 2.本地和远端代码的修改活动详细显示 3.云储存库，储存代码 一句话就是gitlab中存储着远端的代码，git是本地代码和远端代码沟通的桥梁，不过是用命令行的形式，sourcetree是将git变为可见的客户端。 软件安装（以SourceTree为例，其他软件类似）：1.安装git客户端（Git-2.14.0-64-bit.exe）一路Next，但是最后一步有一个是否允许符号链接的勾，按照个人需要选择。不管你选没选，我反正是选了。 2.安装SourceTree（SourceTreeSetup-2.1.2.5.exe） 需要申请一个账户（反正也免费，申就申吧），一路Next。假如GitHub上已经有库的话就可以在这个时候同步下来，没有的话也没关系，反正之后要再建的。当问及是否要创建SSH的时候选否吧，反正之后要手动创建的。 在windows下安装时，当需要使用内置的git，hg时，需要从atlassian.com网站下载。不知道什么原因，总是下载失败。使用Chrome是能够自己下载这两个文件的。使用代理也不好用。所以只有自己下载之后，放在这个目录下，才会好用。 c:\users\YOURUSERNAME\AppData\Local\Atlassian\SourceTree, 把下载好的压缩包解压缩到这个目录下。Git对应git_local,HG对应hg_local。这样就可以在SourceTree中设置使用内置的git和hg了。 另外，需要下载的压缩文件的URL可以在这个目录下的sourcetree.log中找到。下载失败之后会在这里纪录URL。 3.至此软件安装完毕使用SSH链接GitLab：1.利用git bash生成公钥和私钥（使用git bash命令生成gitlab服务端和本地git相互传输时所需要校验的私钥和公钥，公钥用于配置gitlab，私钥用户配置sourcetree。） 打开git bash,输入以下命令： （1）设置git的user name和email：12$ git config --global user.name "test"$ git config --global user.email "test@gmail.com" （2）生成SSH密钥过程：1.查看是否已经有了ssh密钥： 1cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 2.生成密钥：（注意ssh与参数之间没有空格！！！） 1$ ssh-keygen -t rsa -C “邮箱地址” -C 选项后是备注，可随意。命令执行后会要求输入key存储的文件名和passphrase： • 输入一个特有的文件名，否则使用默认的 id_rsa。 • passphrase。不输入也可以。输入之后，提交的时候要输入这个passphrase完成后在 ~/.ssh/ 会生成2个文件。id_rsa 和 id_rsa.pub。前者是私钥，注意保管，后者是公钥。在这里按3个回车，密码为空就可以了。 此时在.ssh文件夹下回生成下面3个文件， 2.在gitlab中配置公钥登录gitlab-&gt;project setting-&gt;SSH,添加即可 打开id_rsa.pub，把内容复制进去 显示如下就OK了 3.sourceTree配置的私钥，与gitlab公钥对应打开sourcetree,点击工具》选项》一般，设置公钥的路径即可。注意客户端选择：OpenSSH 在GitBash中ping一下试试 这样就可以配置成功了！！！ ———————————-华丽丽的分割线———————————- 4.拉取远端代码到本地仓库在gitlab中寻找需要拉取的仓库地址，如下： 在sourcetree中，选择克隆/新建仓库，填写远端和本地的仓库路径，添加即可，之后直接pull 仓库即可。 这样以后可以直接在sourcetree拉取代码了。这里的URL格式需要修改如下： 注意，这次实验使用的端口是8022，具体出现问题的话可以问问我。 Git管理Keil工程：其实很简单，建立仓库后直接把对应的.gitignore文件和工程文件放到Git仓库中，就可以进行commit和push了。 Gitserver建立git仓库的方法群晖的Gitserver不支持通过SSH来登录，所以最好找一个支持账户密码存储的客户端T_T 下面是记录群晖Gitserver创建仓库的方法，以后写个脚本让他自动装机创建吧。 123456789101112cd /volume1/git_reposmkdir xxxx.gitcd xxxx.gitgit init --baresudo -i // 取得root权限cd /volume1/git_repos/chown catonblack:users . // 将gitReposTest目录的所有者改为管理员账户aulati，目录的所属群组改为users。注意不要忘了[.]chmod 770 . // 将gitReposTest目录的所有者、所属群组的权限改为 读/写/运行chown -R git:users xxxx.git // 改变test.git目录及所有包含文件、子目录的所有者chmod -R 770 xxxx.git // 改变test.git目录及所有包含文件、子目录的权限git clone ssh://git@192.168.3.5:9022/volume1/git_repos/test.git 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 漂亮的git分支图 Keil-MDK 使用 Git 作为项目版本管理工具 Keil协同开发存在的问题 Git管理Keil工程实录 解决 需要生成 多个SSH key 的问题]]></content>
      <categories>
        <category>工具使用技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Gitlab</tag>
        <tag>GitHub</tag>
        <tag>GitServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于中心库的NAS,云盘和Git的文件管理方式]]></title>
    <url>%2F2017-08-03%2Ffile-manage%2F</url>
    <content type="text"><![CDATA[对于我这种重度强迫症患者来说，多台PC间、以及多个项目间的文件管理一直是令我抓狂的地方。所以最近抽了一段时间来进行文件的整理，研究了一下Git、云盘以及符号链接的特性，并根据自己的使用习惯进行了设计。这里将这部分经验分享一下。 以下内容适合有多台PC的Windows用户，只有一台PC（以后也不会同时用多台PC）的人可以不看了，用MAC的土豪不用看了，因为没在MAC上试过（估计也不行），用Linux的人也不用看了，理由同上。 与其说是NAS,云盘和Git的使用心得，不如说是建立了一套基于中心库的文件管理方式。 背景：假设有四台电脑：第一台台式机，放在办公室作为主力PC；第二台台式机，放在实验室用于调试；第三台台式机，放在家里；第四台笔记本，随身携带。开始蛋疼了： PC1： C:30G D:200G E:200G F:1.5T PC2： C:60G D:200G PC3： C:256G D:256G E:150G F:500G G:1.5T PC4： C:512G蛋疼点1：假如在办公室改的图纸，要拿到实验室去调，发现一些问题需要晚上拿回家再改，那样就得需要用个U盘从这台PC拷到另一台PC，拷来拷去，如果中间还需要修改和添加批注的话，时间一长，自己也很有可能不知道哪个文件是哪个版本。。。 蛋疼点2：假设AD指向的库目录没法一致，例如PC1指向的是D盘，PC3指向的是G盘，PC4指向的是C盘。那么当把一个项目从PC1拷到PC3的时候就会出现一大堆弹窗，通知你没找到库，然后就得一个个手动添加，AD指向的库目录有的还特别深，感觉整TM不爽。。。 蛋疼点3：如果各个项目之间有交叉有耦合，例如项目1里面的器件可以在项目2里面用，在项目1的规格书里添加了备注，这时候项目2开始了，可以把项目1的文件复制到项目2，之后又在项目2中添加备注，多次往复添加的备注就会不一样，时间一长铁定遗忘。 蛋疼点4：使用Onenote和Endnote的时候，不建议直接将文件附件直接插入，理由同上，会导致同一个文件有多个版本，内容会不一致；也不建议直接打印到笔记本里，因为Onenote会打印成图片，小的文件还好，大的文件就会大大增加Onenote的体积，3M的PDF就可能会变成100M+的图片，十分蛋疼。这种时候就建议有一个指向链接，链接到相应的文件，而假如在不同的电脑上链接的位置不一样就又会导致蛋蛋火辣辣地疼。 蛋疼点5：如果直接使用NAS等网盘工具进行同步的话，需要同步的代码编译出来的一大堆文件不光占地方，而且极容易导致同步冲突。虽然可以添加文件例外，但是不同项目有着不同的要求，每一个都不太一样，无法使用通用的文件例外适配所有程序。 蛋疼点6：有些文件不希望他实时同步，例如Comsol的文件，结果会存在mph文件中，使得文件特别大，这种文件一般是希望把结果删掉之后再保存的，不然的话，一下子就好几个G，没有哪个网盘可以HOLD住的。 ———————————————-还要用，所以不割———————————————— 首先要大致介绍一下符号链接：这东西就类似于指针，假设把G:\Lib指向C:\Lib，文件的位置依然在G:\Lib，但是操作C:\Lib中的文件也会有同样地更改，这点类似于快捷方式。但是它不同于快捷方式的地方在于： 1. 快捷方式其实是一个.INK的文件，使用资源管理器打开；符号链接只是一个指向链接，由操作系统调度。 2. 其他软件中是无法打开快捷方式的，但是可以打开符号链接。 3. 复制快捷方式得到的还是快捷方式，但是复制符号链接得到的是源文件。例如你复制C:\Lib，其实得到是G:\下的文件。Git的介绍再另一篇里有，在此不再赘述。 —————————————————可以割了—————————————————- 接下来就是见证奇迹的时刻如下图所示，所有文件夹的真实位置在G盘根目录下，先将所有目录在C:/CentralLib中进行重新分配，尽可能设计成扁平化的文件夹风格。因为每台windows电脑肯定有C盘（什么？你的windows装在了D盘！好吧，你牛X），这样就让系统误认为所有文件都在C盘。然后从C盘将文件分别映射到E:/Work下的各个工程文件夹，这样就能保证不同的工程文件夹后来用的是同一套库了。 特点： 网盘适合同步几十K~几十M的文件，最好是不会产生大量临时文件的那种，即使产生临时文件也是可以随时删掉而不会对文件造成影响。例如PDF,OFFICE文档，pcb文件，压缩后的工程存档。 NAS因为是内网，所以同步速度特别快，除了对网盘文件进行同步以外，还可以对一些临时性的文件进行快速同步，以免文件丢失。例如网上下载到的参考固件，网上下到的一些小工具等。 GIT适合对二进制文件同步，因为它每次只上传修改后的部分，而且可以手动调整分支，可以指定上传的文件。这些性质对于代码，仿真这种可能会有多种分支，试错成本又低的场合是非常合适的。 使用符号链接，在C盘创建一个虚拟的中心库，然后再将工作盘和其他文件指向这个中心库，原始文件则可以按照各自最合适的方式进行同步。 没有适配所有文件的同步方式，建议使用各自最合适的同步方式来同步。 当项目需要存档和打包的时候，直接复制就可以了，复制符号链接得到的是源文件。 2019-03-01 更新最近确定硬盘挂了，在酿成大错之前赶快备份数据，这时候之前的符号链接让我犯难了，不能直接copy，这样的话会将源文件直接复制过去的，所以这里用了xcopy指令。 复制包含符号链接的目录： 1xcopy e:\test j:\test /e /B 源 e:\test 目标 j:\test]]></content>
      <categories>
        <category>强迫症专题</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>NAS</tag>
        <tag>云盘</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泡面鉴赏]]></title>
    <url>%2F2017-03-01%2Finstant-noodles%2F</url>
    <content type="text"><![CDATA[某日心血来潮，想要研究一下比较著名的进口泡面，于是就通过万能的淘宝买了一些进行品鉴。不得不说，买家秀和买家秀的确差异蛮大的，在这里记录一下，以备以后查阅。 在开始前，本次品鉴仅采用包装内的配料和食材，采用包装后推荐的烹饪方法进行烹饪，所拍的实物照片没有进行任何的调整与修正，目的是为了让结果更加的客观公正。 170119 MyKuai红酸辣汤 下次这种面必须要用煮的，面饼有点粗，泡着不好吃。口味酸辣，有明显的虾酱的味道，带一点甜味，可能是鱼露和糖。 面饼：缺数据， 调料：9分，这个味道很开胃， 香味：缺数据，不喜欢虾酱的气味的人请慎重 外观：缺数据， 方便程度：7分， 综合：8分，各项比较均衡。170121-2220 新加坡百胜厨辣螃蟹面 煮之前才发现原来是拌面，说是要用两口锅煮，一口煮面，一口热调料。但是我调料是用沸水泡的，毕竟只有一口锅。口味咸咸，加了泰式甜辣酱，有螃蟹的味道，但是很明显不是刚做好螃蟹的那种味道。 面饼：8分，毕竟非油炸的面饼没有油炸面饼好。 调料：6分，和预计的差别比较大，虽然的确有螃蟹的感觉。 香味：6分，能很明显地闻到螃蟹的味道，但是由于是东南亚风味，所以晚上在房间里吃的人得三思。 外观：7分，还行，但是看上去不如日清等泡面“有料” 方便程度：4分，居然要用两口锅煮。。。 综合：6分，勉强及格，但是和预想差距比较大。170122-2230 MyKuai白咖喱面 老实说这款面刚吃上去是让我有点失望的，感觉就是国内康师傅香辣牛肉面的翻版嘛。但是表面的辣油下面是一种带点甘甜的白咖喱，味道比较柔和，感觉还不错。口味咸辣，表面的辣油下面是带点甘甜的白咖喱。气味中有点鱼肉罐头的味道。 面饼：8分，很普通的泡面口感，感觉和康师傅差不多。 调料：5分，吃上去第一口特别像康师傅，但是吃到后来的白咖喱给这款面涨了一点分。 香味：3分，有一种东南亚食物的味道，有小鱼干罐头的味道，带一点点甜味，但是不喜欢的人可能会觉得有点臭吧。 外观：3分，长得和康师傅香辣牛肉面一个样，你觉得分数能高到哪里？！ 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：4分，有点失望，4分不能再高了。170123-1820 新加坡百胜厨叻沙面 味道有点奇妙，是一种香甜的口感，有浓浓的椰香，还有一种东南亚风情，虾酱配合椰子的香甜给人一种热情里带着温柔的美好口感。整体口味偏甜咸，有炼乳的感觉。 面饼：8分，感觉这个面饼煮了之后变得很劲道，配合这个汤料还是不错的。 调料：7分，吃起来的感觉还可以，但是总感觉还差点，可能是我不习惯这种又咸又甜还带点奶油的口味吧。 香味：8分，闻上去是香甜的，给人一种温柔的感觉，让人特别有食欲。 外观：7.5分，白中透红的色泽还不错，至少比上一款要好很多。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：7.5分，各项比较均衡，口味也比较温婉，整体还是不错的。170125-1610 韩国农心辛拉面黑袋 请无视碗里的鸡蛋。。。面条劲道，口味咸鲜，带着辣味，虽然没有什么特色，但是各个地方都很均衡，气味温和，没有那种特别重的味道，这点和东南亚的泡面相比就特别明显，口味咸淡适中，并没有特别重的咸味或辣味。 面饼：9.5分，劲道，口感好。 调料：7分，味道均衡，虽然很普通，但是吃完后有一种回味无穷的感觉。 香味：7分，比较普通，但是吃完后味道就散掉了，整体比较均衡 外观：7分，比较普通，没有之前的泡面来的有视觉冲击力。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：8分，看上去普通，但是吃着却比较舒服，值得推荐。170126-0620 韩国八道咕咕鸡丝面 鸡丝面，算是口味比较清淡的一款泡面，气味也不大，整体特别均衡。没有康师傅那股中药味儿，面饼也比较劲道，口味咸鲜，有一点点胡椒的辣味，但却没有那股强烈的胡椒味。口味清淡。但是和东渚的鸡丝面相比，也没有那么明显的鸡肉味，不要太在意他的名字。 面饼：9分，劲道，口感不错，发现韩国的泡面面饼整体都比中国的好，不至于煮两下就烂。 调料：6.5分，比较清淡，有点鸡汤味儿，但是不是那么明显。 香味：6.5分，没有特别重的气味，整体都比较均衡。 外观：7.5分，很淡雅，看上去比较普通。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：7.5分，没有想象中的鸡汤面的感觉，但是依然不错，至少比康师傅的要好。170127-0810 印度尼西亚营多拉面 味道好极了，口味甜咸鲜，带点辣味，但辣味不是很重。味道比较经典，有一种让人吃了就停不下来的感觉。面饼比较普通，但是调料包一共5包的创意着实有诚意。气味还可以，不像其他东南亚泡面般有着十分强烈的气味，久久不散去。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：9分，一共五种调料，口味比较丰富，看上去特别有诚意。 香味：7分，不同于之前的两种东南亚泡面，这款面的气味还是很温和的，气味中带点甜味，不错。 方便程度：8分，煮法和普通泡面差不多，但这是没有汤的干拌面，总的来说还是比较方便的。 综合：9分，吃上去味道真的不错，强烈推荐。20170131-1553 韩国八道韩式炸酱面 口味甜鲜，是韩国传统的大酱风味，口味不错，也是强烈推荐。调料包味道不是特别重，吃的时候以及吃完之后不会有特别咸的味道。有一点点大酱的苦味，但是真的只有一点点，非但没有让整体失衡，反而让整体的口味变得更加均衡。唯一感觉美中不足的地方就是吃完后有一种杯盘狼藉的感觉，毕竟大酱的颜色比较深。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：9分，口味甜鲜，不是很重口，吃完后没有特别咸的负担。酱料特别醇厚，厚的哟实在无法想象。。。 香味：7分，老实说其实没什么特别的香味，就只是大酱的味道，但是气味不是特别恐怖，所以7分还是OK的。 方便程度：9分，面饼煮一下，然后往料上一放就OK了，目前觉得特别方便，但是建议料包最好加热一下。 综合：8分，吃上去的整体感觉不错，强烈推荐。170201-0831 韩国八道韩式海鲜拉面 口味咸鲜，偏辣，虽然号称是海鲜拉面，但是和东南亚的冬阴功面区别较大，口味偏淡，并不像日清或康师傅的那样有浓浓的海鲜味，整体还算均衡，最大的特点应该是它的料包里面有真·墨鱼干，当然了，其实也就只有一点点了。总体来说比较平均，但是也因此没有什么特点。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：6分，比较普通的味道，吃过后其实没有什么特别的感觉，还算可以。 香味：6.5分，也很普通，并没有什么特别的，气味不是特别大。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：6分，马马虎虎的一款，感觉没什么特点。170203-0810 新加坡百胜厨咖喱风味 感觉上像是之前的新加坡百胜厨叻沙面再加点辣，整体感觉并没有许多特别的地方。这种辣味不是特别明显，只是带了一点而已，不重，但是在整体香甜的口味里却也有一定的美感和突出。椰子粉的味道其实不错，但是这道面给人一种腻的感觉。马马虎虎吧。 面饼：8分，感觉这个面饼煮了之后变得很劲道，配合这个汤料还是不错的。 调料：6分，还可以，但是加了辣椒之后的味道感觉怪怪的。 香味：8分，闻上去是香甜的，给人一种温柔的感觉，让人特别有食欲。 外观：7分，奶油的一样的外观整体还可以，仅有的一点点辣油也起到了点缀的作用。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：7分，与叻沙面一比就觉得没有什么特色，整体还算可以，如果不喜欢奶油味或椰子味的话就不推荐了。170227-0810 印度尼西亚营多加辣拉面 和普通的营多拉面相比就是多加了辣椒，其他基本没差。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：8.5分，一共五种调料，口味比较丰富，看上去特别有诚意。这款稍微加了点辣，不重。 香味：7分，不同于之前的两种东南亚泡面，这款面的气味还是很温和的，气味中带点甜味，不错。 方便程度：8分，煮法和普通泡面差不多，但这是没有汤的干拌面，总的来说还是比较方便的。 综合：8.5分，吃上去味道真的不错，推荐。]]></content>
      <categories>
        <category>傻屌如我</category>
      </categories>
      <tags>
        <tag>泡面</tag>
        <tag>进口</tag>
        <tag>品鉴</tag>
      </tags>
  </entry>
</search>
