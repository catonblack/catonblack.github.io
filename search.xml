<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[if……else 和 case 的综合结果]]></title>
    <url>%2F2019-07-17%2Fif-else%2F</url>
    <content type="text"><![CDATA[在某些资料中关于if else和case的综合结果有着不同的结论，有的资料表明虽然RTL原理图综合结果差别比较大但是最后的technology map确实一样的；而有的资料里又说if else这种结构会产生先后顺序，这样就意味着和case语句生成的结果应该不一样。网上的资料各有各的理论依据和实际结果，到底哪个是正确的谁也没个结果。为了一探究竟，我专门做了这个实验。 实验目的探究如下内容： [√] 1. if else 和 case 在不同的综合器中的综合结果是咋样的？ [√] 2. 硬件上的先后顺序到底是怎么实现的？ [√] 3. 针对组合逻辑电路和时序逻辑电路的综合结果是否有区别？ [√] 4. If else有先后顺序和无先后顺序是怎么实现的？ [√] 5. 不同综合器的综合结果对整体结果的影响？ [√] 6. 组合逻辑电路中如果else为空会怎么样？ 如果你懒得看下面的过程，请点击传送门：实验结论 实验内容实验一Code： 12345678910111213141516171819module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验二Code： 12345678910111213141516171819202122module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b00) data &lt;= 2'b00; else begin end endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验三Code： 12345678910111213141516171819module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验四Code： 1234567891011121314151617181920module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验五Code： 123456789101112131415module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00;endendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验六Code： 123456789101112131415161718module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else begin endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验七Code: 123456789101112131415module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验八Code： 12345678910111213141516module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验九Code： 1234567891011121314151617module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else data &lt;= 2'b10;endendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验十Code： 12345678910111213141516module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default: data &lt;= 2'b10; endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 实验十一 always@(*) begin Z = A[4]; if (C[0] == 1'b1 ) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; else Z = A[4]; //可以放在此位置 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; else Z = A[4]; //可以放在此位置 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; else Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; //放在此处，上面的if被阻塞 end always@(*) begin if (C[0] == 1'b1) Z = A[0]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; Z = A[4]; //放在此处，上面的if被阻塞 end always@(*) begin if (C[0] == 1'b1 ) Z = A[0]; else if (C[1] == 1'b1) Z = A[1]; else if (C[2] == 1'b1) Z = A[2]; else if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; end 结果分析 对比实验一和二，三和四，以Xilinx为例，可以得出：在时序逻辑电路中，if..else写不写else都会综合成正确的结果，case有没有default也都会综合成正确的结果； always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end end always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b00) data &lt;= 2'b00; else begin end end end a) 实验一 ISE Spartan6 Technological 原理图 b) 实验二 ISE Spartan6 Technological 原理图 always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end end always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcase end end c) 实验三 ISE Spartan6 Technological 原理图 d) 实验四 ISE Spartan6 Technological 原理图 对比实验一和二，三和四，五和六，七和八，可以得出：无论是组合逻辑电路还是时序逻辑电路，如果else或default的内容为空，那么其综合结果与这部分不写是一样的，这点跟软件完全不一样，这点要注意； always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else begin end end a) 实验五 ISE Spartan6 Technological 原理图 b) 实验六 ISE Spartan6 Technological 原理图 always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default; endcase end c) 实验七 ISE Spartan6 Technological 原理图 d) 实验八 ISE Spartan6 Technological 原理图 但是对比实验五和九，七和十，可以得出：组合逻辑电路中，if…else如果省略else，就会综合成锁存器，包含else就不会综合出锁存器，这点在case语句中也一样； always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; else data &lt;= 2'b10; end a) 实验五 ISE Spartan6 Technological 原理图 b) 实验九 ISE Spartan6 Technological 原理图 always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default: data &lt;= 2'b10; endcase end c) 实验七 ISE Spartan6 Technological 原理图 d) 实验十 ISE Spartan6 Technological 原理图 对比实验一和三，可以得出：对于时序逻辑电路，ISE中if…else的综合结果与相同条件下case的综合结果不相同，quartusii与synplify中，这两种情况的综合结果是相同的。ISE的综合结果中，case要少用一个lut和fdr，总的来说case的综合结果应该是更好一点的；现在看来ise的性能的确不怎么地。。。Vivado中两者的综合结果已经很接近了，但是case的综合结果依然会少一根线，看样子还是case胜出。 always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end end always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end end a) 实验一 ISE Spartan6 Technological 原理图 b) 实验三 ISE Spartan6 Technological 原理图 c) 实验一 VIVADO ZYNQ7 Technological 原理图 d) 实验三 VIVADO ZYNQ7 Technological 原理图 e) 实验一 Synplify Spartan6 Technological 原理图 f) 实验三 Synplify Spartan6 Technological 原理图 g) 实验一 Quartus Cyclone IV E Technological 原理图 h) 实验三 Quartus Cyclone IV E Technological 原理图 i) 实验一 Synplify Cyclone IV E Technological 原理 j) 实验三 Synplify Cyclone IV E Technological 原理 对比实验五和七，可以得出：对于组合逻辑电路，if…else和case在ISE中的综合结果不相同，case的结果要更加节省资源一点；if…else和case在Quartus中的综合结果也不相同，case的结果使用的资源更少一点；而在Synplify中，if…else和case的综合结果是完全一致的；vivado中case的综合结果更加符合预期，少用一根线。总的来说还是case的综合结果更好一点。 always@(*) begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; end always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; endcase end a) 实验五 ISE Spartan6 Technological 原理图 b) 实验七 ISE Spartan6 Technological 原理图 c) 实验五 VIVADO ZYNQ7 Technological 原理图 d) 实验七 VIVADO ZYNQ7 Technological 原理图 e) 实验五 Synplify Spartan6 Technological 原理图 f) 实验七 Synplify Spartan6 Technological 原理图 g) 实验五 Quartus Cyclone IV E Technological 原理图 h) 实验七 Quartus Cyclone IV E Technological 原理图 i) 实验五 Synplify Cyclone IV E Technological 原理 j) 实验七 Synplify Cyclone IV E Technological 原理 接上条，对比的过程中发现Quartus的综合器会将锁存器的输出与其中一个输入相连，形成闭环，推测Quartus综合器在综合的过程中会自动将条件补全并输出当前值。 由于Quartus生成的RTL视图可读性比较好，所以这些实验使用Quartus来综合。else放在最开始就相当于给之后的所有if添加默认输出； always@(*) begin if (C[0] == 1'b1 ) Z = A[0]; else if (C[1] == 1'b1) Z = A[1]; else if (C[2] == 1'b1) Z = A[2]; else if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; end always@(*) begin Z = A[4]; if (C[0] == 1'b1 ) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end 放在其他位置时，else会阻塞前面的if语句，假如放在第4个if后面的else 里面，那么前面3个if就被阻塞了，因为第4个的else中已经包含了前三个if语句的条件，要时刻记住always块中的阻塞赋值生成的组合逻辑电路是按照顺利执行的。 既然是按照顺序，那第4个if的else里面已经包含了前面的if条件，那么前面条件就没有意义，而综合软件在进行综合时，就将前面3个if语句优化掉，即不会生成对应的电路。同样道理，放在第一个if后面的else中是可以的。 always@(*) begin if (C[0] == 1'b1) Z = A[0]; else Z = A[4]; //可以放在此位置 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; else Z = A[4]; //可以放在此位置 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; else Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; else Z = A[4]; //放在此处，上面的if被阻塞 end 没有else也会有阻塞产生，只不过会比有else的多阻塞一下。 always@(*) begin Z = A[4]; if (C[0] == 1'b1 ) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; Z = A[4]; //放在此处，上面的if被阻塞 if (C[3] == 1'b1) Z = A[3]; end always@(*) begin if (C[0] == 1'b1) Z = A[0]; if (C[1] == 1'b1) Z = A[1]; if (C[2] == 1'b1) Z = A[2]; if (C[3] == 1'b1) Z = A[3]; Z = A[4]; //放在此处，上面的if被阻塞 end 结论 时序逻辑电路中if…else无论有没有else，case无论有没有default，都可以综合成正确的电路；但是在组合逻辑电路中，if如果没有else（包括else内容为空或保持输出）/ case如果没有default（包括default内容为空或保持输出），就会综合出锁存器，如果补全了else选项就会综合出相应的组合逻辑电路； 不同综合器对于if…else和case的综合结果不尽相同，总的来说还是case的综合结果更好； 对比if…else和case的综合结果，对于时序逻辑电路，Synplify=Quartusii&gt;Vivado&gt;ISE；对于组合逻辑电路，Synplify&gt;Quartusii&gt;Vivado&gt;ISE，Synplify的优点主要是更加智能； 对于像Synplify和Quartusii这样的综合器，其实if…else和case的综合结果是几乎一样的，这说明综合器越来越聪明，但是考虑到代码的可移植性，还是用case更好一点； 在组合逻辑电路中，目前已知只有实验中的Quartus会自动将条件补全并输出当前值，但是综合器依然会生成锁存器； 如果有多个if，第一个else会默认成为之后所有if的默认值； else如果放在其他位置，会阻塞前面的所有if语句，所以放在不同的位置也就会产生不同的综合结果，所以这里的编码原则就是尽可能让代码没有歧义； 其实硬件电路本身是没有优先级之分的，对于if这样的语法，最好是可以实现条件互斥，如果条件本身不能互斥，那么综合器会扩展这些条件，然后根据扩展后的真值表进行结果判断。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Verilog中if..else和case语句分析 关于FPGA中是用if-else还是select-case Verilog——if语句的优先级问题 状态机跑飞的例子 多路选择器]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>if……else</tag>
        <tag>case</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态机一段式、二段式和三段式写法的实际效果]]></title>
    <url>%2F2019-07-16%2Ffsm-style%2F</url>
    <content type="text"><![CDATA[根据写法不同，状态机分为一段式状态机、两段式状态机和三段式状态机。对于硬件描述语言来说，不同的写法往往会综合出不同的硬件电路。网上大多数资料都仅仅只是介绍了各种状态机的写法，而今天我要来研究研究不同写法综合出来的实际结果的差异。 好的状态机标准好的状态机的标准很多，最重要的几个方面如下： 状态机要安全，是指FSM不会进入死循环，特别是不会进入非预知的状态，而且由于某些扰动进入非设计状态，也能很快的恢复到正常的状态循环中来。这里面有两层含义：其一要求该FSM的综合实现结果无毛刺等异常扰动；其二要求FSM要完备，即使受到异常扰动进入非设计状态，也能很快恢复到正常状态。 状态机的设计要满足设计的面积和速度的要求。 状态机的设计要清晰易懂、易维护。 有限状态机有三种常见的编写方法，一段式，两段式和三段式，他们各自有着不同的优缺点，下面将进行对比。 一段式状态机 不推荐当把整个状态机写在一个always模块中，并且这个模块既包含状态转移，又含有组合逻辑输入/输出时，称为一段式状态机。不推荐采用这种状态机，因为从代码风格方面来讲，一般都会要求把组合逻辑和时序逻辑分开；从代码维护和升级来说，组合逻辑和书序逻辑混合在一起不利于代码维护和修改，也不利于约束。 特点: 1. 将所有的逻辑写在一个always块中，增加代码复杂度，给后期更改维护带来不便。 2. 由于其中有状态寄存器，整体使用non-blockin，描述输出组合逻辑时，需要提前一个时钟，需要额外注意。Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] q_sm_state );//parameterparameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//statemachinealways @(posedge clk or posedge rst) begin if(rst) begin q_sig4 &lt;= 0; q_sm_state &lt;= IDLE; end else begin case(q_sm_state) IDLE: begin if(sig1 || sig2) begin q_sm_state &lt;= WAIT; q_sig4 &lt;= 1'b0; end else begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 1'b0; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin q_sm_state &lt;= DONE; q_sig4 &lt;= 1'b0; end else begin q_sm_state &lt;= WAIT; q_sig4 &lt;= 1'b0; end end DONE:begin if(sig3) begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 1'b1; end else begin q_sm_state &lt;= DONE; q_sig4 &lt;= 1'b0; end end default: begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 0; end endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 两段式状态机 推荐使用所谓的两段式状态机就是采用一个always语句来实现时序逻辑，另外一个always语句来实现组合逻辑，提高了代码的可读性，易于维护。不同于一段式状态机的是，它需要定义两个状态—-现态和次态，然后通过现态和次态的转换来实现时序逻辑。 特点: 1. 两段式状态机可以较清晰完整的显示出状态机的结构。 2. 可以轻易的将状态图state diagram转换为verilog code。 3. 代码清晰，降低编写维护复杂度。Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] current_state );reg [1:0] next_state;//参数声明parameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//状态跳转程序设计always @(posedge clk or posedge rst) if(rst) current_state &lt;= IDLE; else current_state &lt;= next_state; //状态逻辑输出always @(*) begin case(current_state) IDLE: begin if(sig1 || sig2) begin next_state = WAIT; q_sig4 = 1'b0; end else begin next_state = IDLE; q_sig4 = 1'b0; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin next_state = DONE; q_sig4 = 1'b0; end else begin next_state = WAIT; q_sig4 = 1'b0; end end DONE:begin if(sig3) begin next_state = IDLE; q_sig4 = 1'b1; end else begin next_state = DONE; q_sig4 = 1'b0; end end default: begin next_state = IDLE; q_sig4 = 0; end endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 三段式状态机 推荐使用三段式状态机与两段式状态机的区别：两段式直接采用组合逻辑输出，而三段式则通过在组合逻辑后再增加一级寄存器来实现时序逻辑输出。这样做的好处是可以有效地滤去组合逻辑输出的毛刺，同时可以有效地进行时序计算与约束，另外对于总线形式的输出信号来说，容易使总线数据对齐，从而减小总线数据间的偏移，减小接收端数据采样出错的频率。三段式状态机的基本格式是：第一个always语句实现同步状态跳转；第二个always语句实现组合逻辑；第三个always语句实现同步输出。 特点: 1. 三段式状态机可以清晰完整的显示出状态机的结构。 2. 可以轻易的将状态图state diagram转换为verilog code。 3. 代码清晰，降低编写维护复杂度。 4. 在简单状态机（状态少，转移条件少这类）的应用上，三段式代码量和一二段的比较起来长些。Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] current_state );reg [1:0] next_state;//参数声明parameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//状态跳转程序设计always @(posedge clk or posedge rst) if(rst) current_state &lt;= IDLE; else current_state &lt;= next_state;//状态跳转输出always @(*) begin case(current_state) IDLE: begin if(sig1 || sig2) begin next_state = WAIT; end else begin next_state = IDLE; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin next_state = DONE; end else begin next_state = WAIT; end end DONE:begin if(sig3) begin next_state = IDLE; end else begin next_state = DONE; end end default: begin next_state = IDLE; end endcaseend//逻辑输出always @(posedge clk or posedge rst) if(rst) q_sig4 &lt;= 1'b0; else begin case(next_state) IDLE, WAIT: q_sig4 &lt;= 1'b0; DONE: q_sig4 &lt;= 1'b1; default: q_sig4 &lt;= 1'b0; endcase endendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 刚才的例子是一个三状态Moore状态机，状态少，也比较简单，区别效果不是很明显，接下来看一个四状态的Moore状态机，状态机之间的跳转也更加复杂。 一段式状态机Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg out );reg [2:0] NS; //NextStateparameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//1 always block to describe state transition, state output, input conditionalways @ (posedge clk or posedge rst) begin if (rst) begin NS &lt;= IDLE; out &lt;= 3'b000; end else begin case (NS) IDLE: begin if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (i1 &amp;&amp; i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i1 &amp;&amp; ~i2) begin out&lt;=3'b111;NS &lt;= ERROR;end end S1: begin if (~i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i2 &amp;&amp; i1) begin out&lt;=3'b010;NS &lt;= S2; end if (i2 &amp;&amp; (~i1)) begin out&lt;=3'b111;NS &lt;= ERROR;end end S2: begin if (i2) begin out&lt;=3'b010;NS &lt;= S2; end if (~i2 &amp;&amp; i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (~i2 &amp;&amp; (~i1))begin out&lt;=3'b111;NS &lt;= ERROR;end end ERROR: begin if (i1) begin out&lt;=3'b111;NS &lt;= ERROR;end if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end end endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 两段式状态机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg out );reg [2:0] NS,CS;parameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= IDLE; else CS &lt;=NS;//combinational condition judgmentalways @ (*) begin case (CS) IDLE: begin if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (i1 &amp;&amp; i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i1 &amp;&amp; ~i2) begin out&lt;=3'b111;NS &lt;= ERROR;end end S1: begin if (~i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i2 &amp;&amp; i1) begin out&lt;=3'b010;NS &lt;= S2; end if (i2 &amp;&amp; (~i1)) begin out&lt;=3'b111;NS &lt;= ERROR;end end S2: begin if (i2) begin out&lt;=3'b010;NS &lt;= S2; end if (~i2 &amp;&amp; i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (~i2 &amp;&amp; (~i1))begin out&lt;=3'b111;NS &lt;= ERROR;end end ERROR: begin if (i1) begin out&lt;=3'b111;NS &lt;= ERROR;end if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end end default: begin NS &lt;= CS; out &lt;= 3'b111; end endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 三段式状态机Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg [2:0] out );reg [2:0] NS,CS;//parameter [2:0] //one hot with zero idleparameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= IDLE; else CS &lt;=NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) IDLE: begin if (~i1) NS &lt;= IDLE; if (i1 &amp;&amp; i2) NS &lt;= S1; if (i1 &amp;&amp; ~i2) NS &lt;= ERROR; end S1: begin if (~i2) NS &lt;= S1; if (i2 &amp;&amp; i1) NS &lt;= S2; if (i2 &amp;&amp; (~i1)) NS &lt;= ERROR; end S2: begin if (i2) NS &lt;= S2; if (~i2 &amp;&amp; i1) NS &lt;= IDLE; if (~i2 &amp;&amp; (~i1)) NS &lt;= ERROR; end ERROR: begin if (i1) NS &lt;= ERROR; if (~i1) NS &lt;= IDLE; end default: NS &lt;= CS; endcaseend//3rd always block, the sequential FSM outputalways @ (posedge clk or posedge rst) begin if (rst) begin out &lt;= 3'b000; end else begin case (NS) IDLE: begin if (~i1) out&lt;=3'b000; if (i1 &amp;&amp; i2) out&lt;=3'b100; if (i1 &amp;&amp; ~i2) out&lt;=3'b111; end S1: begin if (~i2) out&lt;=3'b100; if (i2 &amp;&amp; i1) out&lt;=3'b010; if (i2 &amp;&amp; (~i1)) out&lt;=3'b111; end S2: begin if (i2) out&lt;=3'b010; if (~i2 &amp;&amp; i1) out&lt;=3'b000; if (~i2 &amp;&amp; (~i1))out&lt;=3'b111; end ERROR: begin if (i1) out&lt;=3'b111; if (~i1) out&lt;=3'b000; end default: out&lt;=3'b111; endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 结果分析1.三状态Moore状态机综合结果排序：三段式&gt;两段式&gt;一段式。可以看出，相对于一段式状态机，两段式状态机和三段式状态机所需要的硬件资源更少。 一段式 两段式 三段式 a) ISE Spartan6 RTL 原理图 b) ISE Spartan6 RTL 原理图 c) ISE Spartan6 RTL 原理图 d) ISE Spartan6 Technological 原理图 e) ISE Spartan6 Technological 原理图 f) ISE Spartan6 Technological 原理图 g) Synplify Spartan6 Technological 原理图 h) Synplify Spartan6 Technological 原理图 i) Synplify Spartan6 Technological 原理图 j) Quartus Cyclone IV E RTL 原理图 k) Quartus Cyclone IV E RTL 原理图 l) Quartus Cyclone IV E RTL 原理图 m) Quartus Cyclone IV E Technological 原理图 n) Quartus Cyclone IV E Technological 原理图 o) Quartus Cyclone IV E Technological 原理图 p) Synplify Cyclone IV E Technological 原理图 q) Synplify Cyclone IV E Technological 原理图 r) Synplify Cyclone IV E Technological 原理图 2.四状态Moore机的综合结果，两段式的资源消耗最少，三段式和一段式的综合结果就不一定了，有的情况是三段式更加节省资源，有的时候居然是一段式更加节省资源。 一段式 两段式 三段式 a) ISE Spartan6 RTL 原理图 b) ISE Spartan6 RTL 原理图 c) ISE Spartan6 RTL 原理图 d) ISE Spartan6 Technological 原理图 e) ISE Spartan6 Technological 原理图 f) ISE Spartan6 Technological 原理图 g) Synplify Spartan6 Technological 原理图 h) Synplify Spartan6 Technological 原理图 i) Synplify Spartan6 Technological 原理图 j) Quartus Cyclone IV E RTL 原理图 k) Quartus Cyclone IV E RTL 原理图 l) Quartus Cyclone IV E RTL 原理图 m) Quartus Cyclone IV E Technological 原理图 n) Quartus Cyclone IV E Technological 原理图 o) Quartus Cyclone IV E Technological 原理图 p) Synplify Cyclone IV E Technological 原理图 q) Synplify Cyclone IV E Technological 原理图 r) Synplify Cyclone IV E Technological 原理图 3.时序对比，预估时钟频率一段式和两段式的最高，三段式的频率反而最低。 一段式/MHz两段式/MHz三段式/MHz 3SM_Moore_Xilinx678.6678.6675 3SM_Moore_Altera907.9907.9907.9 4SM_Moore_Xilinx682.2682.2670.3 4SM_Moore_Altera919.6919.6907.3 4.网上找到的三种描述状态机方法的比较 5.小插曲在进行综合的过程中遇到了一个有意思的问题：Synplify没有识别状态机。综合结果只在一段式状态机中提取出了状态机，在两段式和三段式写法中居然没有提取出来。这不科学！要知道Synplify对FSM有专门的处理的，没道理提取不出来。后来发现原因是这样的：两段式和三段式状态机中状态转移部分是组合逻辑电路，一定要补全默认分支，否则就会被综合成锁存器，同时也就不会自动提取状态机信息了，这点要特别注意。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 基于FPGA的有限状态机浅析 Verilog有限状态机三段式描述方法 Verilog学习笔记（四） 有限状态机 FPGA三段式状态机的思维陷阱 Verilog语法_3(同步有限状态机) 三段式状态机设计 有限状态机FSM学习笔记 Verilog三段式状态机描述及模版 FPGA状态机 如何写好状态机]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>有限状态机</tag>
        <tag>综合</tag>
        <tag>多段式状态机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨时钟传递多个时钟信号]]></title>
    <url>%2F2019-07-16%2Fmultisignal-cdc%2F</url>
    <content type="text"><![CDATA[此文是对Clifford E. Cummings 大神的 paper：《Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs》的部分节选与翻译。本人翻译水平有限，还望大家轻拍。以后如果在实际场景中遇到相同或类似的问题，到时候再会补充的。 原文A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. Simply using synchronizers on all control signals is not always good enough as will be shown in the following examples. If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs. 译文对于工程师而言，在处理跨时钟域问题的过程中一个常犯的错误就是在将多个信号从一个时钟域传送到另一个时钟域的过程中忽略控制信号之间的时序。对所有信号仅使用同步器进行同步对于下面要介绍的应用场景是不够的。如果信号顺序和信号间的对齐很重要，那么在处理的过程中就需要格外小心了。接下来举的例子都是简化过后的案例，但是跟实际情况中经常遇到的问题非常类似。 问题1： 传递两个同时需要的信号(b_load和b_en)原文In the simple example shown in Figure 8, a register in the new clock domain requires both a load signal and an enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded. 译文正如下图案例中介绍的那样，在新时钟域中的这个寄存器需要一个负载信号和一个使能信号以保证寄存器的输入值有效。即使负载信号和使能信号都出自于同一个时钟域，两个信号间依然有概率会产生一个小的抖动，这有可能会使这两个信号在新的时钟域被同步入不同的时钟循环。在这个案例中，这就可能导致数据无法被寄存器正确识别。 图1 问题：传递两个同时需要的信号 解决方法：只传递一个信号(b_lden)原文The solution to the problem in this simple example is easy. As shown in Figure 9, drive both the load and enable register input signals in the new clock domain from just one control signal. This will remove the potential for the control signals arriving shifted in time. 译文解决这个问题的方法其实哼简单。正如下图介绍的那样，将寄存器的两个驱动信号合并成一个控制信号，然后传送入新的时钟域。这种方法将移除控制信号到达新时钟域后产生错位的可能。 图2 解决方法：只传递一个信号 问题2：传递两个前后顺序控制的信号(ben1和ben2)原文The diagram in Figure 10, shows two enable signals, aen1 and aen2, that are used to enable the sequential passing of a data signal through a short pipeline design. The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop. 译文下图中的两个使能信号aen1和aen2用于在一个流水线结构中顺序地将数据信号进行传送。这里的问题在于：在第一个时钟域，信号aen1可以在信号aen2置位前立刻结束，但是第二个时钟域可能会对aen1与aen2之间的这个极窄的空隙时间进行采样，这就导致在第二个时钟域中的使能控制信号链会产生一个时钟的空缺，这也将导致a2输出信号被第二个触发器错过。 图3 问题：传递两个前后顺序控制的信号 解决方法：只传递一个信号(ben1)原文The solution to the problem, as shown in Figure 11, is to send only one control signal into the new clock domain and generate the second phase-shifted sequential control signal within the new clock domain. 译文下图显示了解决这个问题的一种方法：将一个时钟信号传递到新的时钟域并在新的时钟域产生第二个相移顺序控制信号。 图4 解决方法：只传递一个信号 问题3：传递两个编码控制信号(bdec[0]和bdec[1])原文The diagram in Figure 12 shows two encoded control signals being passed between clock domains. If the two encoded signals are slightly skewed when sampled, an erroneous decoded output could be generated for one clock period in the new clock domain. 译文下图显示了另外一种常见的问题：两个编码控制信号在时钟域间传递。如果这两个编码控制信号间极窄的抖动被采样到，那么在新的时钟域就会产生一个时钟的编码输出误差。 图5 问题：传递两个编码控制信号 解决方法1：产生一个ready信号(bden_n)来指示数据的有效性原文One potential solution to this problem, as shown in Figure 13, is to send a shaped enable signal to act as a “ready flag” in the new clock domain. The sending clock domain must generate and enable signal one clock cycle after asserting the decoder inputs. The sending clock domain must also remove the enable signal one clock cycle before de-asserting the decoder inputs. As described earlier, the enable signal must be asserted for a time period that is longer than the cycle time of the receiving clock domain. 译文第一种解决方法是发送一个经过整形的使能信号，这个信号在新时钟域中的作用就是一个“准备妥当标志位”。在编码输入信号置位后发送时钟域必须生成和使能一个时钟的信号。发送时钟域必须在输入信号复位前一个时钟移除使能信号。正如之前所提到的那样，使能信号必须置位一个时钟周期，并且这个时钟周期必须小于接收时钟域的一个时钟周期。 原文Under worst case conditions, the shaped enable signal will either be sampled at the same time as the encoded inputs are sampled into the receiving clock domain, or the shaped enable signal will be de-asserted at the same time as the encoded inputs are de-asserted in the receiving clock domain. Under best case conditions, the shaped enable pulse will be asserted one receiving clock cycle later than the assertion of the encoded inputs and de-asserted one receiving clock cycle before the de-assertion of the encoded inputs. This method insures that the encoded inputs are valid before they are enabled into the receiving clock domain. 译文在最坏的条件下，整形后的使能信号既不会在编码输入被接收时钟域采样的同时被采样到，也不会在编码输入在接收时钟域复位的同时而复位。在最好的情况下，整形后的使能信号会在编码输入置位的一个时钟后置位，并且在编码输入复位的一个时钟前复位。这种方法可以保证编码输入在接收时钟域使能前就有效了。 图6 解决方法1：产生一个ready信号(bden_n)来指示数据的有效性 解决方法2：使用one-hot key信号结合状态机来处理接收到的信号原文A second potential solution to this problem, as shown in Figure 14, is to decode the signals back in the sending clock domain and then send the decoded outputs (where only one of the outputs is asserted) through synchronizers into the new clock domain. Within the new clock domain, a state machine is used to determine when a new decoded output has been asserted. If there are no decoded outputs, it means that one decoded output has been de-asserted and that another decoded output is about to be asserted. If there are two asserted decoded output signals, the last decoded output signal will cause the state machine to change states and the older decoded output signal will turn off on the next rising clock edge in the new clock domain. It is important that the sender insure that the decoded outputs are each asserted for a time period that is longer than the cycle time of the receiving clock domain. 译文如下图显示，第二种解决这个问题的方法是在发送时钟域将信号进行编码，然后将编码后的信号（独热码）通过同步器发送到接收时钟域。新的时钟域中有一个状态机用来决定编码输出何时被置位。如果此时没有编码输出，这就意味着一个输出已经被复位了而另一个输出正准备置位。如果此时有两个编码输出置位，新的编码输出信号将导致状态机状态改变，而上一个编码输出信号将在新时钟域的下一个时钟上升沿复位。需要特别注意的是，发送端必须保证编码输出一次仅置位一个时钟周期，并且这个时钟周期不会比接收时钟域的一个时钟长。 原文Any time there are multiple control signals crossing clock boundaries, caution must be taken to insure that the sequencing of the control signals being passed is correct or that any potential mis-sequencing of the control signals will not adversely impact the correct operation of the design. 译文凡是在有多个控制信号跨越时钟边界的时候，控制信号必须保证时序正确，或者控制信号的任意潜在失序将不会影响这个设计的正确操作。 图6 解决方法2：使用one-hot key信号结合状态机来处理接收到的信号 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>异步时钟</tag>
        <tag>多信号同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Verilog 项目配置]]></title>
    <url>%2F2019-03-17%2Fhdl-prjsetting%2F</url>
    <content type="text"><![CDATA[根据以前的经验、书籍和网上的资料，自己总结了一个简单的项目设置，虽然做不到正规公司那么规范，但是尽自己可能地让自己做的设计更加完善，然后一步一步规范化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445project├── board #-存放不同电路板对应的配置文件│ ├── AX516│ └── PHASE2_R2│ ├── impact_bit.cmd #-用于下载bit文件的脚本│ ├── impact_mcs.cmd #-用于将bit文件转变成mcs文件的脚本│ ├── impact_spi.cmd #-用于下载mcs文件的脚本│ ├── top_sys.ucf #-PCB约束文件│ ├── top_sys.ut #-bit文件的设置参数│ └── top_sys.xst #-xst设置文件├── doc│ └── html #-doxygen生成的程序解释├── ipcore_dir #-ip存放的位置├── ise #-ise工程存放的文件夹，综合过程中生成的文件也将在这个文件夹里│ ├── clear.bat #-win下用于清理文件夹的批处理文件│ ├── comp.bat #-win下用于综合等的批处理文件│ └── Makefile #-用于综合，布局布线，生成bit，mcs并下载├── rtl #-工程源代码├── script #-常用脚本的备份│ ├── clear.bat│ ├── clearip.bat│ ├── msim.tcl│ ├── signal.rc│ ├── sim.bat│ ├── top_sys.prj│ ├── top_sys.ut│ └── top_sys.xst├── simpostsyn_ctrl_usb_com #-综合后仿真文件夹│ ├── filelist.f #-本次仿真的文件列表│ ├── Makefile #-将综合与仿真的过程结合在一起，节省很多时间│ ├── novas.rc #-verdi的配置文件│ └── signal.rc #-信号列表├── simrtl_ctrl_usb_com #-RTL仿真文件夹│ ├── filelist.f│ ├── Makefile│ ├── novas.rc│ └── signal.rc├── tb #-仿真所需要的顶层文件│ ├── tb_ctrl_usb_com.v│ └── tb_mdl_buf_mux.v└── tcdc #-chipscope配置文件│ └── chipscope.cdc├── shellX64.sh #-shell脚本，64bit├── shellX86.sh #-shell脚本，32bit└── readme.md #-工程简介文件]]></content>
      <categories>
        <category>强迫症专题</category>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>项目存档</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立保持时间的原理解释]]></title>
    <url>%2F2019-02-18%2Fsetup-hold-time%2F</url>
    <content type="text"><![CDATA[我们知道，对于时序逻辑电路，有一个比较重要的参数便是采样/保持时间。理想电路的时钟上升沿时间是0，只要信号在时钟上升沿之前就可以实现触发器的数据改变；而实际电路的时钟上升时间不为0，信号也必须要在时钟上升沿前后保持一段时间才可以实现锁存，否则就可能遇到亚稳态问题。可是时序逻辑电路为什么会需要采样/保持时间？这篇笔记就是为了探究这个现象背后的原理。 关于亚稳态现象，请参考博文《》。 SR锁存器SR锁存器是触发器最基本的组成结构，要解释触发器为啥需要采样/保持时间，首先就要先解释一下SR锁存器的原理。 我们以使用或非门搭建的SR锁存器为例，来讲解一下： 如下图，SR锁存器默认状态下Q输出为1，Q’输出为0。 假设在下个瞬间，将R设置为1，此时上面的或非门另一个输入为0，此时输出Q会变为0，那么下面的或非门两个输入均为0，此瞬间Q’的输出则为1，那么上或非门的两个输入即都为1，此时输出Q为0。正好形成稳定的状态。 在下个瞬间，将S设置为1，R设为0，此时下面的或非门两个输入均为1，则输出Q’为0，那么上或非门的两个输入即都为0，此时输出Q为1。正好形成稳定的状态。 总结一下真值表： SRQQnext备注 0000维持 0011维持 0100复位 0110复位 1001置位 1011置位 110-不允许 111-不允许 为啥触发器会需要采样/保持时间？下面我们就来探讨一下触发器为什么会有建立时间和保持时间的要求。我们先假设原来的数据为1，新的要锁存的数据为0。 首先 D 触发器的门级电路原理图如下所示： 如图所示D触发器内部包含两个D锁存器，靠近输入端的锁存器称为主D锁存器，靠近输出端的锁存器称为从D锁存器。要让触发器的输出为0，也就是要让从锁存器的输出为0，也即要让主锁存器在时钟发生跳变之后将数据稳定地锁存在0。换句话说，时钟边沿跳变之后主锁存器负责锁存数据，而从锁存器则负责传输主锁存器锁存好的数据，这样我们就把问题简化为研究主锁存器在时钟跳变瞬间的状态。 这里以时钟上升沿为例，也就是D触发器在clk信号0-&gt;1时锁存数据，咱们来看下在这个时间点发生了哪些事。将主锁存器单独提取出： 先讨论建立时间假设时钟上升沿到来后数据的建立时间不足，或者说数据0相对于时钟上升沿来的太晚会怎样？ 假设在 T=0ns 的时候，clk 从 0 变成 1（为方便分析，假设时钟是理想的，没有跳变延时）。这时候信号可能会在两个时间点过来，为了便于分析，我们将这两个时间点的信号看成两个信号，分别是D1和D2。其中，D1=0 在 T=-0.7ns 的时候到达数据的端口，这个信号满足建立时间；另一个信号 D2=0 在 T=-0.3ns 的时候才来到数据端口，这个信号不满足建立时间。换句话说就是D1来的足够早，D2来的足够晚。 D1信号0经过反相器(NOT1)成为了1(B1)，经过与门(AND1)得到1（R1）（此时时钟上升沿还没有来，所以clk为0，即与门的另一个输入为1），经过或非门(NOR1)之后输出Q1变成了0，也就是从锁存器要锁存的0。主锁存器Q刚输出0时还不稳定，需要经过反馈使得或非门(NOR1)的另一个输出为1，即需要t1+t2+t3来维持Q的稳定。 D2信号刚经过非门(NOT1)到达与门(AND1)，时钟上升沿很快就到了，此时在与门(AND1)后形成一个很短的脉冲，在一些极限条件下，这个脉冲甚至可能没有。脉冲的时间肯定小于t1+t2+t3，也就意味着锁存器可能没法实现稳定锁存，这就是建立时间不足的引起锁存不住值的原因。 由此分析得出，建立时间的实质应该是主锁存器的稳定时间t1+t2+t3与A，B两段导线传播时间差的和。 接下来讨论保持时间：也就是说数据相对时钟上升沿撤销地太早会怎样？ 如下图：如果撤销地足够晚，也就是D1在THOLD（这里的THOLD只是示意图，参考下面的分析会看到实际的THOLD十分接近B的下降沿）之后才撤销，S1在这段时间里时钟为0，而R1却会存在一个向上的脉冲（如上段文字所述）。此时即可得到输出Q1为0。 接下来看卡如果撤销的太迅速会咋样：撤销地太迅速，也就意味着D2在B下降沿之前就置位了，R2虽然不受影响，但是此时由于S2是B2与D2做与得到，所以S2会存在一个向上的脉冲，也就是说S2与R2在这个时刻可能会同时置位，由SR锁存器的真值表可知，此时输出Q2可能会出错。 由这个分析可知保持时间的本质其实是 从CLK到AND2输入的时间t1 与 从D到AND2输入的时间t2 的差值。 由于在集成电路中，一个D触发器内部的连接线长度极短，信号通过逻辑门的时间往往要长很多，所以一般情况下保持时间会比建立时间小。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Lockup latch – principle, application and timing FPGA中Verilog语言综合出锁存器的问题 Verilog 锁存器 触发器 寄存器区别 FPGA设计中latch的产生原因、危害与避免措施 FPGA 中的latch 锁存器 锁存器的一点总结 锁存器 Latch v.s. 触发器 Flip-Flop IC 设计基础系列之 CDC 篇 7：从 CMOS 到触发器 Latches and flip-flops 锁存器（latch）、触发器（flip-flop）、寄存器（register）的区别 Difference between Latches and Flip-Flops Know all about Latches and Flip Flops Designing of D Flip Flop The Spartans Creating Latches in Schematics Creating Latches Spartan-6 Slice Spartan6 Slice M configuration D Flip-Flop (edge-triggered) D Flip-Flop The D Flip-Flop]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>锁存器</tag>
        <tag>触发器</tag>
        <tag>建立时间</tag>
        <tag>保持时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latch vs Flip-Flop]]></title>
    <url>%2F2019-02-11%2Flatch-vs-flipflop%2F</url>
    <content type="text"><![CDATA[对于数字工程师来说，锁存器的存在一直是一个暧昧而又说不清道不明的存在。经常会在综合报告中看到一些warning提示生成了锁存器，而且一般的设计规则也不建议有锁存器。那么，锁存器到底是啥？它跟触发器又有什么区别和联系呢？ 除非特别声明，否则本文中的锁存器特指D锁存器，触发器特指D触发器。 基本定义D锁存器Latch 是 透明的(transparent)，就是说输入的变换立即就能传递到输出端口，当几个透明的锁存器级联时，输入端的信号也能立即传递到输出端。当给锁存器添加额外的逻辑电路（比如使能信号 enable 无效时），就会使它变为 不透明的(non-transparent)。下面的D锁存器就是这样的例子。 仔细观察SR锁存器的功能表，就可以发现，R 的取值为 S 的补。D锁存器利用了这一特点，而且避免了SR锁存器中的禁止状态的出现。 因为SR锁存器的实现有两种，所以D锁存器的实现也对应有两种： NOR D Latch NAND D Latch D锁存器的真值表： E/CDQQ'备注 0XQprevQ'prev无变化 0001复位 0110置位 D锁存器也称为非透明锁存器、数据锁存器、门控存器。它有一个数据输入端和一个使能端 enable(clock、control)。 D触发器下图是基本触发器的内部结构示意图： 如果D锁存器的控制端口加入时钟信号，就得到了基本触发器，只要时钟信号 CLK = 1，则触发器就会受到触发，当 CLK 保持为 1 时，数据输入端口的任何变化都将影响到锁存器的状态。 锁存器的这个特点应用到时序电路中，就会出现比较严重的问题： 一般时序逻辑的输出会经过组合电路的反馈通道，返回到时序逻辑的输入。当时钟信号有效时，锁存器的输出通过组合电路反馈到锁存器的输入端，如果经过组合逻辑后，反馈的信号和之前的信号不同，则反馈信号会导致锁存器的输出变为新的值。在时钟信号有效的期间内，锁存器的输出一直在变化，出现了不可预测的结果，这是不可靠的工作。 锁存器的问题就在于：它在时钟有效期间内一直在被触发，这种触发时间过长。 这个问题的解决方法就是：将触发条件变为时钟沿触发，这样就得到了触发器 flip-flop。 D 触发器 将锁存器改造为边沿敏感的触发器，最简单的就是D触发器，搭建电路最经济有效的方法就是使用D触发器，因为它需要的门电路最少，其他类型的触发器都是在D触发器的基础上得到的。 实现 DFF 可以有两种方法： Classical positive-edge-triggered D flip-flop Master–slave edge-triggered D flip-flopclk = 1 时，master D-latch 使能，D 传递到输出端 Q； clk = 0 时，slave D-latch 使能，输入 D (master D-latch 的输出 Q) 传递到输出 Q； 可以看到，当 clk 从 1 变为 0 时，输入端的 D 才传递到输出端 Q，也就是说在时钟的下降沿才触发，其他时刻都保持输出不变。（如果需要上升沿触发，只需要在 clk 输入端键入一个反相器） DFF 的特点就是在时钟信号的特定点触发（上升沿 or 下降沿），真值表： CLKDQnext 上升沿00 上升沿11 非上升沿XQ 两者的对比 LatchesFlip-Flops 面积比触发器小。门电路是构建组合逻辑电路的基础，而锁存器和触发器是构建时序逻辑电路的基础。门电路是由晶体管构成的，锁存器是由门电路构成的，而触发器是由锁存器构成的。也就是 晶体管->门电路->锁存器->触发器，前一级是后一级的基础。锁存器完成同一个功能所需要的门较触发器要少，所以在asic中用的较多。由于一个Flip-Flop至少由两级SR锁存器组成，那么其面积肯定比锁存器大，消耗的门电路比锁存器多。在CPLD中，基本单元 LE 是查找表 LUT 和触发器 FF 组成的，如果要实现锁存器，反而需要更多的资源。 锁存器由电平触发，非同步控制。在使能信号有效时锁存器相当于通路，在使能信号无效时 latch 保持输出状态。触发器由时钟沿触发，同步控制，用于存储二进制数据。 电平触发，非同步设计，受布线延迟影响较大，很难保证输出没有毛刺产生，这对于下一级电路是极其危险的。边沿触发，同步设计，不容易受毛刺的印象。 不能异步复位，所以上电以后处于不确定的状态。可以异步复位 Latch会使静态时序分析变得非常复杂。时序分析简单 锁存器根据控制信号类型可以分为：D锁存器、SR锁存器、T锁存器和JK锁存器。R触发器根据控制信号类型可以分为：D触发器、SR触发器、T触发器和JK触发器。 锁存器是由逻辑门组成的。触发器是由锁存器与额外的时钟信号组成的。 锁存器很快，用在地址锁存是很合适的，不过一定要保证所有的latch信号源的质量，锁存器在CPU设计中很常见，正是由于它的应用使得CPU的速度比外部IO部件逻辑快许多。触发器比较慢 锁存器耗电更少，因为触发器一直要受时钟边沿控制。触发器耗电较多，因为锁存器既可以不使用时钟，也可以使用时钟。 通常，透明锁存器仅考虑D-Q传播延时。触发器要考虑CLK到Q延时，以及建立保持时间。 锁存器一般被认为是"透明"的。触发器因为边沿触发影响，往往是“非透明”的。 锁存器是否真的碰不得？一般的设计规则是：在绝大多数设计中避免产生 latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch 最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用 D 触发器的地方，就不用 latch。 但是，锁存器作为一种电路单元，必然有其存在的理由及应用场景，在实际应用中，有些设计不可避免的要使用Latch，特别是总线应用上，例如，地址锁存器，数据锁存器，复位信号锁存器等。但是在更多的情况下，很容易产生未预料到的锁存器，使逻辑功能不满足要求，浪费大量时间。比较好的应用规则是：要学会分析是否需要Latch以及代码是否会产生意外的Latch。 “期望”的锁存器通过Verilog HDL实现序列最大值搜索程序，并保持检测到的最大值： Code： 12345678910111213module top_sys( input wire [7:0] a, input wire rst_n, output reg [7:0] abmax);always @ (*) begin if (!rst_n) abmax &lt;= 8'h00; else if (a &gt; abmax) abmax &lt;= a;endendmodule 12345678910111213141516171819=========================================================================* HDL Synthesis *=========================================================================Synthesizing Unit &lt;top_sys&gt;. Related source file is &quot;E:\GitRepository\Blog_Temple\FPGA_LATCH_VS_FF\rtl\top_sys.v&quot;.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;6&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;5&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;4&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;3&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;2&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;1&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;0&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.WARNING:Xst:737 - Found 1-bit latch for signal &lt;abmax&lt;7&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems. Found 8-bit comparator greater for signal &lt;abmax[7]_a[7]_LessThan_1_o&gt; created at line 12 Summary: inferred 8 Latch(s). inferred 1 Comparator(s).Unit &lt;top_sys&gt; synthesized. 上述代码在ISE中的综合结果会给出设计中包含Latch的警告。但实际上，abmax_tmp锁存器正是我们需要的，所以，虽然有警告，但是代码设计是没有问题的。将上述代码的if语句补全： 1234if (a &gt; abmax) abmax &lt;= a;else abmax &lt;= abmax; 经过综合后，仍然有Latch的警告。无论Latch是否是用户需要的，ISE都会给出警告，主要原因就是Latch对整个设计的时序性能影响较大。所以，在设计中要尽量避免Latch，但是确实需要使用的情况，也可以使用。 ###“不期望”latch 指的是与设计意图不符，产生的Latch。主要问题在于设计人员没有合理使用Verilog HDL语言，常见的原因是对条件语句（if、casse）的分支描述不完整。典型例子：用Verilog HDL实现一个锁存器，当输入数据大于127时，将输入数据输出，否则输出0。 123456789module latch_demo( input wire [7:0] din, output reg [7:0] dout);always @ (din) begin if (din&gt;127) dout &lt;= din;endendmodule 综合后的结果，在比较器后面级联了锁存器，这是因为if语句缺少else分支造成的。查看仿真结果，当输入小于127时，输出保持了上次的127，不是0，没有达到设计要求。修改方法很简单，就是将if-else补全。 1234if (din&gt;127) dout &lt;= din;else dout &lt;= 0; 在ISE中综合后的结果中，可以看到补全if-else后，在比较器后面级联了与门，代替原来的锁存器，仿真结果也正确。 D锁存器的其他应用锁存器用来锁存数据，这是初始的功能应用，这里来聊聊锁存的其他的简单应用吧。 锁存器的常用应用就是用来防电路毛刺了，具体的应用就是门控时钟了，这里请查看我的另外一篇博文，那里有较为详细的关于门控电路的描述。大家看到这条是不是有点蒙？没关系，我也是，之后我会写一篇来介绍的。 锁存器有一种叫做锁定锁存器（ lockup latch）的玩意用于修复扫描链插入时引起的时钟偏移问题，帮助修复保持时间违规，具体情况可以查看Lockup latch – principle, application and timing。 有 些地方没有时钟，也只能用 latch 了。比如现在用一个 clk 接到 latch 的使能端 (假设是高电平使能), 这样需要的 setup 时间，就是数据在时钟的 下降沿之前需要的时间，但是如果是一个 DFF，那么 setup 时间就是在时钟的上升沿需要的时间。这就说明如果数据晚于控制信号的情况下，只能用 latch, 这种情况就是，前面所提到的 latch timing borrow。基本上相当于借了一个高电平时间。也就是说，latch 借的时间也是有限的。 类似通过修复保持时间来增强性能、锁存器流水线的应用，这些应用很难三言两语的说明，有些我也不太懂，以后用到的时候再详细研究吧。 PS：1. 关于SR锁存器和触发器建立/保持时间的相关内容 可以参考我的另一篇博客。 2. 以前想过一个问题，明明在FPGA的结构中看到了锁存器，但是为什么大多数资料都会说锁存器会导致消耗更多的资源呢？主要是因为CPLD中没有锁存器，所以需要大量的逻辑。 由于我并没有使用CPLD的项目，所以在网上找到一张示意图展示用DFF来生成锁存器： 3. FPGA的FF是否可以配置成LATCH？ 试了一下布局布线后的结果，在FPGA中FF可以配置成LATCH，FF中的CLK在这里被配置成G，RST被配置成CLR。 4. ASIC中Latch面积更小？ （待补充一个直观的结果）参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Lockup latch – principle, application and timing FPGA中Verilog语言综合出锁存器的问题 Verilog 锁存器 触发器 寄存器区别 FPGA设计中latch的产生原因、危害与避免措施 FPGA 中的latch 锁存器 锁存器的一点总结 锁存器 Latch v.s. 触发器 Flip-Flop IC 设计基础系列之 CDC 篇 7：从 CMOS 到触发器 Latches and flip-flops 锁存器（latch）、触发器（flip-flop）、寄存器（register）的区别 Difference between Latches and Flip-Flops Know all about Latches and Flip Flops Designing of D Flip Flop The Spartans Creating Latches in Schematics Creating Latches Spartan-6 Slice Spartan6 Slice M configuration D Flip-Flop (edge-triggered) D Flip-Flop The D Flip-Flop]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>锁存器</tag>
        <tag>触发器</tag>
        <tag>锁存器处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moore 与 Mealy 状态机的互相转换]]></title>
    <url>%2F2019-01-18%2Fmealy2moore%2F</url>
    <content type="text"><![CDATA[根据哲学原理，讲完世界观就得讲方法论，讲完区别就得意识到事物之间是有普遍联系的，他们可以在一定条件下进行转化。状态机之间也不例外。 先讲Mealy-&gt;Moore的过程首先请出这次举例所需要的Mealy状态机，如下图： 这个状态机有三个状态：S0，S1和S2，仔细观察后不难发现指向S1的箭头有两种输出： 0和 1，指向S2的箭头也有两种输出：0和1，也就是说对于S1状态来说，状态机的输出并不仅仅与状态本身有关，还与状态机的输入有关，所以这是一个Mealy状态机。 接下来就是见证奇迹的时刻。高呼，汽车人，变形！哦，不，状态机，变形！ 第一步，先确定复位后的初始状态为S0，然后S0临近的两个状态分别为S1和S2。分别画上指向箭头，然后就存在了S0分别指向S1与S2的状态。如下图： 第二步，分析原状态机图，发现S1有两个输出，此时再使用一个状态就不太合适了，所以这时将S1拆分成两个状态：S10和S11，分别表示输出为0和1的两个状态；同理将S2也分解为S20与S21。如下图： 第三步， 在原始状态机中S1有指向S0的箭头，这两个转换过程的输出均为0，所以画两根箭头指向S0。如下图： 第四步， 参考第三步，S1在输入为0 时会指向S2，而且输出为1，所以这里画两根箭头指向S21。如下图： 第五步，在完成第四步的基础上画两根箭头由S20和S21指向S10。如下图： 锵锵，大功告成，Mealy状态机被完美改造成了Moore状态机。稍微做下整形： 再讲Moore-&gt;Mealy的过程Moore状态机转换成Mealy状态机的过程相对来说就要简单一些了。 下图是需要转换的Moore状态机。 第一步，观察状态机的组成，发现有两个状态机之间没有直接的联系，即这两个状态机之间没有箭头连接，他们就是A和D。然后观察到这两个状态机都有箭头指向状态B和状态C，所以这两个状态是可以融合的。 第二步，将A与D融合后产生新的状态AD’，同时，状态B和状态C就转变成新的状态B’和C’。然后在这个基础上进行调整和整理就得到了下面这张图。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Mealy to Moore and Moore to Mealy Transformation FSM 有限状态机 verilog三段式状态机设计实例（moore和mealy） 状态机的模型之Moore型状态机 状态机的模型之Mealy型状态机]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>有限状态机</tag>
        <tag>Moore</tag>
        <tag>Mealy</tag>
        <tag>状态机转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摩尔状态机和米勒状态机特性对比]]></title>
    <url>%2F2019-01-16%2Fmoore-mealy%2F</url>
    <content type="text"><![CDATA[之前对比过一段式，两段式和三段式状态机综合结果，在这个过程中发现大家对Moore状态机和Mealy状态机特别容易混淆。所以在这里专门写了这篇博文来详细介绍这些内容。 Moore状态机和Mealy状态机的对比下表以一个例子直观地对比了Moore状态机和Mealy状态机的异同，两者最大的区别在于状态机输出是否跟输入相关。 Moore状态机 Mealy状态机 Moore 状态机是时序逻辑输出只取决于当前状态的这一类状态机，其输出表达式为输出信号 = G(当前状态)。 Mealy 状态机是时序逻辑输出不但取决于状态，还取决于输入的一类状态机，其状态机输出表达式为输出信号 = G(当前状态，输入信号)。Moore状态机与Mealy状态机的性能对比Mealy状态机Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849module top_sys ( input wire clk, input wire rst, input wire i, output reg out );reg [2:0] NS; //NextStatereg [2:0] CS; //CurrentStateparameter S0 = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= S0; else CS &lt;= NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) S0: begin if (i) begin NS &lt;= S2; end else begin NS &lt;= S1; end end S1: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S2; end end S2: NS &lt;= S1; default: NS &lt;= S0; endcaseend//3rd always block, the sequential FSM outputalways @ (*) begin case (CS) S0: out &lt;= 1'b0; S1: begin if (i) out &lt;= 1'b0; else out &lt;= 1'b1; end S2: begin if (i) out &lt;= 1'b0; else out &lt;= 1'b1; end default: out &lt;= 1'b0; endcaseendendmodule Synplify综合结果，682.2 MHz Moore状态机Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152module top_sys ( input wire clk, input wire rst, input wire i, output reg out );reg [3:0] NS; //NextStatereg [3:0] CS; //CurrentStateparameter S0 = 4'b0000;parameter S10 = 4'b0001;parameter S11 = 4'b0010;parameter S20 = 4'b0100;parameter S21 = 4'b1000;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= S0; else CS &lt;= NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) S0: begin if (i) begin NS &lt;= S20; end else begin NS &lt;= S11; end end S11: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S21; end end S10: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S21; end end S20: NS &lt;= S10; S21: NS &lt;= S10; default: NS &lt;= S0; endcaseend//3rd always block, the sequential FSM outputalways @ (*) begin case (CS) S0: out &lt;= 1'b0; S11: out &lt;= 1'b1; S10: out &lt;= 1'b0; S21: out &lt;= 1'b1; S20: out &lt;= 1'b0; default: out &lt;= 1'b0; endcaseendendmodule Synplify综合结果，614.3 MHz Moore vs Mealy 状态机这里对比了两种状态机的特点。 1. Mealy 机比 Moore 机 “响应” 速度快。 Mealy 机的输出与当前状态和输入有关，而 Moore 机输出仅与当前状态有关。Mealy 机的输入立即反应在当前周期；Moore 机的输入影响下一状态，通过下一状态影响输出。为此 Mealy 机比 Moore 机输出序列超前一个周期，即 “响应速度” 较快。Mealy 机的输出在当前周期，具有较长的路径（组合逻辑）；Moore 机的输出具有一个周期的延时，容易利用时钟同步，Moore 机具有较好的时序。 2. Mealy 机状态少，Moore 机结构简单。 由于 Moore 机的输出只有当前的状态有关，一个状态对应一个输出，Moore 机具有更多的状态。Mealy 和 Moore 机之间可以相互转化，对于每个 Mealy 机，都有一个等价的 Moore 机，Moore 机状态的上限为所对应的 Mealy 机状态的数量和输出数量的乘积。 3. 状态机的状态通过触发器的数量来反应，Mealy 机具有较少的状态，为此具有较少的触发器。 4. 血的教训告诉我，不能根据输出状态机的写法是否包含不同输入的不同输出而确定这是Mealy状态机还是Moore状态机。附录：有小伙伴表示对Graphviz生成的流程图比较感兴趣，所以在此处呈上两种状态机的Graphviz代码。 Mealy状态机123456789101112131415digraph fsm &#123; rankdir=LR; ratio=&quot;compress&quot; ranksep=1; size=&quot;8.0,8.0&quot;; node [fontsize=25]; node [shape = doublecircle]; S0; node [shape = circle]; &quot;S0&quot; -&gt; &quot;S1&quot; [label= &quot;0/1&quot;] &quot;S1&quot; -&gt; &quot;S0&quot; [label= &quot;1/0&quot;] &quot;S1&quot; -&gt; &quot;S2&quot; [label= &quot;0/1&quot;] &quot;S2&quot; -&gt; &quot;S1&quot; [label= &quot;x/0&quot;] &quot;S0&quot; -&gt; &quot;S2&quot; [label= &quot;1/0&quot;]&#125; 生成流程图如下： Moore状态机123456789101112131415digraph fsm &#123; rankdir=LR; ratio=&quot;compress&quot; ranksep=1; size=&quot;8.0,8.0&quot;; node [fontsize=25]; node [shape = doublecircle]; &quot;S0/0&quot;; node [shape = circle]; &quot;S0/0&quot; -&gt; &quot;S1/0&quot; [label= &quot;0&quot;] &quot;S1/0&quot; -&gt; &quot;S0/0&quot; [label= &quot;1&quot;] &quot;S1/0&quot; -&gt; &quot;S2/1&quot; [label= &quot;0&quot;] &quot;S2/1&quot; -&gt; &quot;S1/0&quot; [label= &quot;x&quot;] &quot;S0/0&quot; -&gt; &quot;S2/1&quot; [label= &quot;1&quot;]&#125; 生成流程图如下： 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Mealy to Moore and Moore to Mealy Transformation FSM 有限状态机 verilog三段式状态机设计实例（moore和mealy） 状态机的模型之Moore型状态机 状态机的模型之Mealy型状态机]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>有限状态机</tag>
        <tag>Moore</tag>
        <tag>Mealy</tag>
        <tag>状态机转换</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[令人闻风丧胆的亚稳态]]></title>
    <url>%2F2018-10-21%2Fmetastability%2F</url>
    <content type="text"><![CDATA[当信号在不相关或者异步时钟域之间传送时，会出现亚稳态，它是导致包括FPGA在内的数字器件系统失败的一种现象。通过计算亚稳态导致的平均故障间隔时间(MTBF)，设计者可以知道是否应采取措施来降低这类失败的概率。 本文介绍FPGA 中的亚稳态现象，解释为什么会出现这一现象，讨论它是怎样导致设计失败的。并且介绍了怎样利用各种设计和器件参数来计算MTBF， 以及FPGA工程师怎样提高MTBF。 什么是亚稳态？对于时序逻辑电路，FPGA等数字器件中所有触发器都有确定的信号时序要求，使每一个触发器能够正确的采集输入数据，产生输出信号。 为保证能够可靠的工作，寄存器输入必须在时钟沿之前稳定一段时间(寄存器建立时间，即tSU)，在时钟沿之后也要保持稳定一段时间(寄存器保持时间，即tH)。一定的时钟至输出延时 (tCO) 之后，寄存器输出有效。如果信号转换不能满足寄存器的tSU 或者tH 要求，寄存器输出就有可能进入亚稳态。在亚稳态中，寄存器输出在高电平和低电平状态之间徘徊一段时间，这意味着，输出延时超出设定的tCO之后才能转换到确定的高电平或者低电平状态。 按照是否由异步时钟产生，亚稳态的来源分为同步时钟亚稳态与异步时钟亚稳态。 同步时钟亚稳态现象指的是信号在同步时钟区域中传递时产生的亚稳态；异步时钟亚稳态现象指的信号在跨时钟传递的过程中所产生的亚稳态。 但是无论是哪种原因产生的亚稳态现象，产生亚稳态的根本原因都是信号的到达时间不满足接收触发器的tSU和tH。 触发器是否会进入压稳态以及返回稳定状态所需要的时间与器件制造工艺以及实际工作条件有关。在大部分情况下，触发器会很快返回稳定状态。 亚稳态的一种解释网上关于触发器有一个非常形象的比喻：把触发器在时钟边沿采样数据信号看成是球从山上滚落下来，如下图所示。山的两边代表稳态，上坡代表旧的数据，下坡代表新的数据，山顶代表亚稳态。如果球处于山顶，它就会处于一种不确定状态，稍微偏向哪一侧就会滚向山下。从山顶滚到山脚的这个过程意味着球到达稳定状态的速度越来越快。 类比到信号上，如果数据信号在时钟沿之后不满足最小的tH，这就类似球从山的“旧数据”一侧落下，输出信号保持在该时钟转换的最初值不变。当触发器数据输入满足于到达时钟沿前的最小tSU时，只要保持时间大于最小tH，这就类似球从山的“新数据”一侧落下，输出信号很快达到稳定的新状态，这样就满足确定的tCO时间要求。但是，当寄存器数据输入不能满足tSU或者tH时，这就类似于球落在山顶附近，那么它会花很长时间才能落到山脚，增加了时钟转换到稳定输出的延时，超出了要求的tCO。 如下图所示：时钟信号转换时，输入信号从低电平状态转换到高电平状态，不能满足触发器的tSU要求。数据输出信号从低电平状态开始，进入亚稳态，在高电平和低电平状态之间徘徊。信号输出A 转换到输入数据的新逻辑1 状态，输出B 返回到数据输入最初的逻辑0 状态。在这两种情况下，输出转换到确定的1 或者0 状态的时间被延迟了，超出了触发器要求的tCO。 在Tell me about Metastability找到了实际测量得到的波形。 在Metastability and Synchronizers: A Tutorial中找到了下图，输入信号与时钟的相互关系会导致不同的输出： 亚稳态的另一种解释以一个CMOS反相器为例，我们从机理上来看看亚稳态的原因。如下图，反相器的输出电流Iout先是随着输入电压Vin的增加而增加，在输入电压Vin达到最大值的一半时，输出电流Iout达到最大值，此时反相器处于亚稳态。可以看到，当Vin处于最大值与最小值时，Iout几乎为0，而Vin处于中间值时Iout值最大，也就是说亚稳态时的电流消耗也是最大。对于触发器来说，输出一般都是反向器，这也就意味着触发器有可能产生亚稳态。 下图展示了非亚稳态与亚稳态时输出电流Iout的曲线，恶意明显地看到亚稳态时输出电流会持续一段时间。 我们知道，CMOS逻辑门在其电压特性曲线上有一个“极值点”，但是如果在锁存器里面这又会变成什么样子呢？在锁存器中有两个反相器首尾相连，下图的电压曲线显示了这两个反相器输入电压与输出电压之间的关系，而两条曲线的交叉点就是亚稳态点。锁存器更加容易进入亚稳态，尤其是在输入信号转变更快的情况下。由于触发器实质上是由两个锁存器连接而成，那么它也必将可能进入亚稳态。而区别就在于触发器进入亚稳态的可能性要大大低于锁存器，因为触发器是边沿敏感，而锁存器是电平敏感。 亚稳态什么时候会导致设计失败？如果数据输出信号在寄存器下次采集数据之前，转换到有效状态，那么，压稳态信号不会对系统工作有不利影响。但是，如果压稳态信号不能在它到达下一设计寄存器之前转换到低电平或者高电平状态，那就会导致系统失败。 同步寄存器同步寄存器链或者同步器是满足以下要求的触发器序列： 链上的寄存器都由相同的或者相位相关的时钟进行同步 链上的第一个寄存器由不相关的时钟域进行驱动，即异步驱动。 每个寄存器只扇出连接一个寄存器，链上的最后一个寄存器除外。同步寄存器链的长度是满足以上要求的同步时钟域中的寄存器数量。 关于同步器请参考（异步时钟处理） 计算亚稳态MTBF一级同步器亚稳态平均故障间隔时间MTBF大致估算了亚稳态导致的两次设施失败之间的平均时间。较大的MTBF( 例如亚稳态失败间隔数百甚至数千年) 表明非常可靠的设计。所需要的MTBF 取决于系统应用。例如，急救医疗设备需要的MTBF 要比消费类视频显示设备长得多。增大亚稳态MTBF 能够减小信号传输导致设备出现亚稳态问题的概率。可以使用设计信息以及器件特征参数来计算设计中某些信号传输或者所有信息传输的亚稳态MTBF。采用下面的公式和参数来计算触发器的MTBF： $$MTBF=\frac{e^{t_{MET} \cdot C_{2}}}{C_{1} \cdot f_{CLK} \cdot f_{DATA}}$$ 其中： C1和C2常数取决于器件工艺和工作条件。 fCLK和fDATA参数取决于设计规范：fCLK是接收异步信号时钟域的时钟频率，fDATA是异步输入数据信号的触发频率。较快的时钟频率以及触发数据能够降低(或者劣化)MTBF。 tMET参数是亚稳态信号达到确切状态的亚稳态建立时间，即超出寄存器tCO的时序余量。同步链的tMET是链上每一寄存器输出时序余量之和。 多级同步器多级同步器的MTBF计算公式如下： $$MTBF(n)=\frac{e^{n \cdot t_{MET} \cdot C_{2}}}{C_{1} \cdot f_{CLK} \cdot f_{DATA}}$$ 计算实例我们用一个实际的例子来展示，在网上值找到了Altera Flex 10K的参数，貌似现在厂家都不提供这种参数了。。。 其中C1=1.01x10^-13， C2=1.268x10^10，tMET=1.41ns，就用这种参数来计算一下吧： 一级同步器：MTBF=2970579s≈1年 两级同步器连用：MTBF=1747394975872859s=5.54*10^7年 看来两级同步器联用就大大提高了这个同步器的稳定性。 系统总MTBF如果设计中包含多个同步链，每一同步器链的MTBF都会影响总的设计MTBF。同步器的失效率是1/MTBF，将每一同步器链的失败概率相加得到整个设计的失败概率，如下所示： $${ failure_rate_{\text{design}} } = \frac { 1 } { MTBF_ { \text{design} } } = \sum _ { i = 1 } ^ { \text { number of chains } } \frac { 1 } { MTBF _ { i } }$$ 设计亚稳态MTBF为 $$ \frac { 1 } { failure_rate_ { \text{design} } } $$ 确定亚稳态常数FPGA供应商可以通过FPGA的亚稳态特性来确定MTBF方程中的常数。确定特性的难点在于典型FPGA设计的MTBF 一般在几年以上，因此，使用真实设计，在实际工作条件下测量亚稳态事件之间的时间间隔是不可行的。 以下是Altera提供的测量MTBF的方法为确定器件亚稳态常数， Altera 使用了如下的测试电路，这一电路具有较短的可测量MTBF。 在这一设计中， clka和clkb是两路不相关的时钟信号。同步器输入数据在每一时钟周期进行触发(较大的fDATA)。同步器长度为1，这是因为一个同步寄存器连接了两个目的触发器。目的触发器在一个时钟周期后以及一个半时钟周期后采集同步器输出。如果信号在下一时钟沿到达之前进入亚稳态，电路探测到采样信号出现了不同，输出一个错误信号。这一电路能够探测到半时钟周期内出现的大部分亚稳态事件。 在器件中很多地方复制了这一电路，以减小本地差异的影响，对每一例化模块进行连续测试，以消除耦合噪声。Altera 对每一测试结构测量一分钟，记录错误数。以不同的时钟频率进行测试，在对数坐标上画出MTBF与tMET的关系。常数C2 对应于试验结果趋势线的斜率，以常数C1线性标出曲线。 Xilinx提供的测量方法如下： 本质上的测量原理与Altera提供的是一样的，这里留这一笔是因为在Xilinx的应用笔记XAPP094《Metastable Recovery in Virtex-II Pro FPGAs》中提到：在时钟速率小于300MHz的时候压根儿就没观察到亚稳态现象。突然间感觉Xilinx好拽。。。毕竟Altera的FAE建议我“Cyclone4不要超过100MHz，Cyclone5不要超过150MHz”。 下图是来自网络的一个真实案例，来自《认识FPGA触发器的亚稳态》 在这个案例中，我们测试一个FPGA逻辑单元中的亚稳态现象。在测试中，我们让sel信号固定在0，那么逻辑关系为 F1 &lt;= local_2m输入，F0 &lt;= local_2m输入，local_2m和cdr_2m都是2MHz的方波信号，被一个50MHz的异步时钟作同步化处理。 Code: 123456789always @(posedge clk_50m) if(sel==1)begin clk2m_oa &lt;= cdr_2m ; clk2m_ob &lt;= cdr_2m ; end else begin clk2m_oa &lt;= local_2m ; clk2m_ob &lt;= local_2m ; end 测试中我们发现触发器的输出clk2m_ob上偶尔有毛刺出现，但是触发器的输入F1和F0上并没有毛刺。而且这个毛刺和下一个clk2m_ob跳变沿的间隔刚好是50MHz的一个周期20nS。 参考图4，红色为F1，黄色为clk2m_ob。 我们来分析下这个毛刺。由于2MHz输入信号local_2m和50MHz时钟clk_50m是异步的，因此毫无疑问会有亚稳态的出现。当亚稳态出现的时候，触发器的输出一开始随机震荡到高电平，但很快亚稳态结束，并返回到”错误的”低电平状态。于是就表现为毛刺。 在测试中，每大约一小时，clk2m_ob就会出现一次这样的毛刺。可以看出亚稳态的捕捉窗口是非常小的。这个实验中大约发生了 60 minutes * 60 seconds/20nS = 180 * 10^9次采样。因此捕捉窗口的大致范围为20nS * (2/25) / (180*10^9) ~= 9 *10^(-12) s = 9 fs. 这么高的精度，没有任何仪器可以精确模拟，这也是为什么亚稳态现象只能用统计的方法去研究的原因。 另一方面，同样的电路功能，clk2m_oa却从来没有出现过这样的毛刺。这说明亚稳态掉表现形式不是固定的。猜测clk2m_oa的亚稳态表现为中间电平的形式，并最终返回到”正确”的状态。由于tR时间非常短，并且亚稳态和信号的边沿混和在一起，无法和正常情况进行区分。根据XAPP094的解释，亚稳态的表现是和器件的PVT(制作工艺Process，电压Voltage，温度Temperature)相关的，并且和具体电路的增益，噪声相关。如果是这样，clk2m_oa和clk2m_ob的各自触发器的或增益或噪声是有差异的，所以表现不一致。 提高亚稳态MTBF由于MTBF 方程中的指数因子， tMET·C2 项对MTBF 计算的影响最大。因此，可以通过优化器件常数C2，改进体系结构来提高亚稳态性能，或者优化设计，增大同步寄存器的tMET。 设计优化MTBF 方程中的指数因子意味着增大设计相关tMET 值能够指数增大同步器MTBF。例如，如果某一器件的常数C2，设置工作条件为50 ps，那么， tMET 只需要增大200 ps，就能够实现指数200/50，提高MTBF e4 倍，即50 多倍，而增大400 ps，提高MTBF e8 倍，即3000 倍。 另一方面，最差MTBF 链对设计MTBF 的影响最大。例如，考虑具有10 个同步链的两个不同设计。一个设计的10 个链有相同的10,000 年MTBF，另一设计的9 个链有一百万年的MTBF，但是一个链的MTBF为100 年。设计失败概率是每一链的失败概率之和，失败概率为1/MTBF。第一个设计的亚稳态失败概率为10 个链× 1/10,000 年 = 0.001，因此，设计MTBF是1000 年。第二个设计的失败概率为9 个链 × 1/1,000,000 +1/100 = 0.01009，设计MTBF 为99 年，略小于最差链的MTBF。 换言之，设计较差的同步链决定了设计的亚稳态总MTBF。由于这一效应，对所有异步信号和时钟域传输进行亚稳态分析非常重要。设计人员或者工具供应商提高最差MTBF同步链的tMET，会对设计MTBF有很大的影响。 为提高亚稳态MTBF，设计人员可以在同步寄存器链上增加额外的寄存器级，以提高tMET 。增加的每一寄存器至寄存器连接时序余量被加到tMET 值中。设计人员一般使用两个寄存器来同步信号，而Altera的白皮书建议使用三个寄存器作为标准，以实现更好的亚稳态保护。然而，增加一个寄存器会在同步逻辑中加入额外的延时级，因此，设计人员必须综合考虑这是否可行。 Xilinx提供的方法如果发现输入信号存在潜在的亚稳态问题，只需创建与同一时钟有相位关系的时钟驱动的寄存器链就能解决此问题。这需要提供如下图所示的电路。 图中，将寄存器链放置在两个单元中：第一个为 ILOGIC 单元，而另外两个寄存器放置在 SLICE 单元中（选择具有相同时钟的 3 个寄存器和链）。这是减少亚稳态问题的一种快速且非常简单的方法，还有其他一些方法不但可减少亚稳态问题，还可优化性能。 使用赛灵思逻辑块的 IDDR 方法在 Virtex-4 和 Virtex-5 FPGA 中，赛灵思将其 ILOGIC 模块直接放置在 I/O 驱动器和接收器的后面。该模块包括 4 个存储元件寄存器和 1 个可编程绝对延迟元件。 Virtex-4 与 Virtex-5 器件均采用这 4 个寄存器来实现双倍数据率输入 (IDDR) 寄存器，功能设计师只需例化 IDDR 原语便能实现。这将使 受益匪浅。 这种原语的其中一个模式称为 SAME_EDGE_PIPELINED。图 2 显示了采用这种模式的 DDR 输入寄存器及相关信号。绿色矩形框显示了一系列最优的寄存器，可用其解决亚稳态问题。此外，使用 IDDR 方法还有一个优势，即能使用两三倍之多的主时钟，同时又不会造成任何设计时延问题。 只需少量代码在《Virtex-4 用户指南》的 328～329 页，举例说明采用 VHDL 和 Verilog 语言编写的 IDDR 原语的例化。以下采用 Verilog 语言的 IDDR 原码例化的典型实例： 1234567891011121314defparam IDDR_INT2.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED"; defparam IDDR_INT2.INIT_Q1 = 1'b1; defparam IDDR_INT2.INIT_Q2 = 1'b1; defparam IDDR_INT2.SRTYPE = "SYNC"; IDDR IDDR_INT2( .Q1 (sync_data ), .Q2 (signal_noload ), .C (CLK_2X ), .CE (1'b1 ), .D (async_data ), .R (), .S ()); 下图是用IDDR设计的全新布局图。 用这种方法将寄存器链放置在两个单元：前两个寄存器放置在 ILOGIC 单元中，另一个寄存器则放置在 SLICE 单元中（这里选择的链具有 3 个寄存器和 2 个不同的时钟，其中一个时钟速度是另一个的两倍）。 结论只要信号不满足触发器的建立保持时间，就会产生亚稳态问题。亚稳态失败平均时间间隔与器件工艺技术、设计规范和同步逻辑的时序余量有关。FPGA 设计人员可以通过增大tMET ，采用增加同步寄存器时序余量等设计方法来提高系统可靠性，增大亚稳态MTBF。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Tell me about Metastability Metastability and Synchronizers: A Tutorial 认识FPGA触发器的亚稳态 Digital Logic metastability FPGA 跨时钟域同步，亚稳态等 利用 IDDR 简化亚稳态 (图) 什么是亚稳态？What is metastability? FPGA 中亚稳态 —— 让你无处可逃 What Is Metastability? 亚稳态分析 Metastability Bibliography Metastability METASTABILITY Metastability 认识FPGA触发器的亚稳态 FPGA建立时间和保持时间详解 稳态与亚稳态小结 特定情况下消除不稳定态的方法 寄存器输出的不稳定态 非同期信号を扱うための危ういVerilogライブラリ Clock Domain Crossing in FPGA FPGA异步复位同步释放使用两级D触发器的意义 亚稳态到底是什么呢？]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>亚稳态</tag>
        <tag>平均无故障时间</tag>
        <tag>亚稳态优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下边沿触发]]></title>
    <url>%2F2018-08-18%2Fup-down-edge%2F</url>
    <content type="text"><![CDATA[一般的资料都会建议不要将电路设计成上下边沿触发，同时一个系统中也尽量不要同时存在时钟上升沿触发和时钟下降沿触发，综合器在处理这类问题的时候会将时钟频率翻倍作为解决方案。 但是根据下面的综合结果发现，综合器会尽可能地把系统设计成单一时钟，而Altera的寄存器貌似支持相反时钟，而Xilinx的会直接根据真值表设计成相同时钟沿的。 同一模块时钟上升下降沿触发123456789101112131415161718192021222324252627282930module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data[0] &lt;= 1'b0; end else begin if (addr[0] == 1'b0) data[0] &lt;= 1'b1; else data[0] &lt;= 1'b0; endendalways@(negedge clk) begin if (rst) begin data[1] &lt;= 1'b0; end else begin if (addr[1] == 1'b0) data[1] &lt;= 1'b1; else data[1] &lt;= 1'b0; endendendmodule a) Quartus Cyclone IV E RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) Quartus Cyclone IV E Technological 原理图 d) Synplify Spartan6 Technological 原理图 同一模块时钟上升沿触发123456789101112131415161718192021222324252627282930module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output reg [1:0] data );always@(posedge clk) begin if (rst) begin data[0] &lt;= 1'b0; end else begin if (addr[0] == 1'b0) data[0] &lt;= 1'b1; else data[0] &lt;= 1'b0; endendalways@(posedge clk) begin if (rst) begin data[1] &lt;= 1'b0; end else begin if (addr[1] == 1'b0) data[1] &lt;= 1'b1; else data[1] &lt;= 1'b0; endendendmodule a) Quartus Cyclone IV E RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) Quartus Cyclone IV E Technological 原理图 d) Synplify Spartan6 Technological 原理图]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>Posedge Clock Edge</tag>
        <tag>Negedge Clock Edge</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的模块间交互的方法]]></title>
    <url>%2F2018-07-18%2Fmodel-interface%2F</url>
    <content type="text"><![CDATA[对系统的模块进行划分之后需要考虑的就是模块之间的信息交互，以下是我整理和总结的常见结构，在这些结构的基础上再根据实际情况进行调整。这篇笔记中的交互方法是针对同步时钟模块进行介绍的，异步时钟模块的使用需要略微调整。 直接交互直接交互不需要接收端反馈，发送端直接发送数据，一般用于下游模块的处理速度快于上游模块的数据发送速度。框图如下图： 典型案例举例：包文汇聚模块，系统框图如下： 此项目中网口A的时钟是40MHz，网口B的时钟是20MHz，网口C的时钟是10MHz，下游模块的工作时钟是80MHz。由于下游模块的处理速度高于上游模块的总发送速录，所以即使三个网口同时发送数据，下游模块任可以完成对所有数据的处理。 因此，下游模块不需要通过反馈信号控制上游模块数据的发送，即采用直接交互架构即可。 rdy交互无缓存rdy交互当rdy为高电平时，表示模块B可以接受模块A的读写命令，开始传输数据，模块A每发送一个数据，模块B就处理，处理完后再发送下一个数据。一般应用于上游模块速率高，下游模块速率低，并且上游模块有缓存的场景。框图如下图。 有缓存rdy交互收到读写命令后，模块A开始传输数据，数据先输入模块B的FIFO，然后模块A和模块B按照各自时钟进行读写FIFO的数据，可以解决读写速率不匹配的问题。一般应用于上下游模块都有缓存的场景。优点是控制简单，对时序要求不太严格。框图如下图。 应答交互模块A请求发送，模块B收到应答后就可以传输数据。一般应用于上游模块等待响应后才能连续发送一段数据的场景。框图如下图: 全握手全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路A声明它的请求信号，然后接收方电路B检测到该请求有效后，声明它的效应信号；当电路A检测到响应信号有效之后，中止自己的请求信号；最后，当电路B检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非A检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路A必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。 全握手鲁棒性很好，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。时序图如下： Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081module top_sys ( input wire clk, input wire rst, input wire trig );reg req;reg ack;reg data;reg [3:0] req_idx;reg [3:0] ack_idx;always @(posedge clk or posedge rst) begin if (rst) begin req_idx &lt;= 4'd0; req &lt;= 1'b0; end else begin case (req_idx) 4'd0: begin if (trig == 1'b1) begin req &lt;= 1'b1; req_idx &lt;= 4'd1; end else begin req &lt;= 1'b0; req_idx &lt;= 4'd0; end end 4'd1: begin if (ack == 1'b1) req_idx &lt;= 4'd2; else req_idx &lt;= 4'd1; end 4'd2: begin req &lt;= 1'b0; req_idx &lt;= 4'd3; end 4'd3: begin if (ack == 1'b0) begin req &lt;= 1'b0; req_idx &lt;= 4'd4; end else req_idx &lt;= 4'd3; end 4'd4: begin req_idx &lt;= 4'd4; end endcase endendalways @(posedge clk or posedge rst) begin if (rst) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end else begin case (ack_idx) 4'd0: begin if (req == 1'b1) begin ack &lt;= 1'b1; ack_idx &lt;= 4'd1; end else begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end end 4'd1: begin if (req == 1'b0) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd2; end else ack_idx &lt;= 4'd1; end 4'd2: begin ack_idx &lt;= 4'd2; end endcase endendendmodule PS：这里留个记号，仿真中明明4个时钟就可以了，为什么资料中显示这里需要5个时钟呢？ 部分握手1部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。在第一种握手方法中，电路A以有效电平声明其请求信号，电路B以一个单时钟宽度脉冲作为响应。此时，电路B并不关心电路A何时中止它的请求。省去了完整握手流程里面的最后一步，也就是ack信号自动会把自己复位，而不是要等检测到req信号复位之后了。时序图如下： 部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module top_sys ( input wire clk, input wire rst, input wire trig );reg req;reg ack;reg data;reg [3:0] req_idx;reg [3:0] ack_idx;always @(posedge clk or posedge rst) begin if (rst) begin req_idx &lt;= 4'd0; req &lt;= 1'b0; end else begin case (req_idx) 4'd0: begin if (trig == 1'b1) begin req &lt;= 1'b1; req_idx &lt;= 4'd1; end else begin req &lt;= 1'b0; req_idx &lt;= 4'd0; end end 4'd1: begin if (ack == 1'b1) begin req_idx &lt;= 4'd2; end else begin req_idx &lt;= 4'd1; end end 4'd2: begin req &lt;= 1'b0; req_idx &lt;= 4'd2; end endcase endendalways @(posedge clk or posedge rst) begin if (rst) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end else begin case (ack_idx) 4'd0: begin if (req == 1'b1) begin ack &lt;= 1'b1; ack_idx &lt;= 4'd1; end else begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end end 4'd1: begin ack &lt;= 1'b0; ack_idx &lt;= 4'd2; end 4'd2: begin ack_idx &lt;= 4'd2; end endcase endendendmodule 部分握手1仿真总共占用3个时钟。 部分握手2电路A使用一个单时钟宽度脉冲发出它的请求，电路B也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。省去了完整握手流程里面的最后两步，两个信号在置位保持一段时间以后都是自动复位，不在相互检测。时序图如下： Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162module top_sys ( input wire clk, input wire rst, input wire trig );reg req;reg ack;reg data;reg [3:0] req_idx;reg [3:0] ack_idx;always @(posedge clk or posedge rst) begin if (rst) begin req_idx &lt;= 4'd0; req &lt;= 1'b0; end else begin case (req_idx) 4'd0: begin if (trig == 1'b1) begin req &lt;= 1'b1; req_idx &lt;= 4'd1; end else begin req &lt;= 1'b0; req_idx &lt;= 4'd0; end end 4'd1: begin req &lt;= 1'b0; req_idx &lt;= 4'd1; end endcase endendalways @(posedge clk or posedge rst) begin if (rst) begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end else begin case (ack_idx) 4'd0: begin if (req == 1'b1) begin ack &lt;= 1'b1; ack_idx &lt;= 4'd1; end else begin ack &lt;= 1'b0; ack_idx &lt;= 4'd0; end end 4'd1: begin ack &lt;= 1'b0; ack_idx &lt;= 4'd2; end 4'd2: begin ack_idx &lt;= 4'd2; end endcase endendendmodule 部分握手2仿真总共占用2个时钟 异步时钟特别篇异步全握手时序图： 握手图解： 这种类型的握手使用了电平同步器。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端A需要 5 个周期，接收端B需要 6 个周期。 异步部分握手1时序图： 握手图解： 为了让这种部分握手1方法成立，电路A中止请求信号至少要 1 个时钟周期长度，否则，电路B就不能区别前一个和后一个新的请求。在这种握手方式下，电路B为请求信号使用一个电平同步器；电路A为响应信号使用一个脉冲同步器。只有当电路B检测到请求信号时才发出响应脉冲，这样电路A控制请求信号的时序，就能控制自己同步器接收到的脉冲间隔。同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路A需要花费 3 个时钟周期，接收端B需要花费 5 个时钟周期。 异步部分握手2时序图： 握手图解： 这种握手使用的是脉冲同步器。完整的时序是：电路A需要花费 2 个时钟周期，电路B需要花费 3 个时钟周期。 异步时钟握手总结 因为握手内部采用了同步器，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的同步器和握手信号，就有了前面介绍的 3 种不同的握手方式： 全握手是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。 部分握手是对全握手的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的部分握手。 部分握手1精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了1次半的握手。而且修改了全握手中电平握手的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路A则必须使用脉冲同步器来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的同步器，部分握手1就比全握手方式节约了很多时间。 部分握手2则更进一步，在部分握手1的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成1次握手。而且两部分电路的同步器同时修改为脉冲方式。这样子进一步减少了握手花费的时间。 部分握手和全握手的本质区别不在于同步器的类型和握手信号的多少，而在于握手的方式。 部分握手不用再等待对方的回答，就继续进行自己的下一步操作，而全握手必须等到对方的回复才进行下一步的操作，所以从某种意义上，全握手方式才是真正的“握手”，而部分握手并不符合 “握手” 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 跨越鸿沟：同步世界中的异步信号 cpu与fpga跨时钟域数据交换的实现问题 FPGA 时钟设计 3 —— 跨时钟域设计 跨时钟域设计的一点总结 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>异步时钟</tag>
        <tag>模块交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FPGA 复位研究]]></title>
    <url>%2F2018-07-18%2Ffpga-reset%2F</url>
    <content type="text"><![CDATA[初学FPGA的时候对FPGA的理解最多停留在always@阶段，后来有次跟同事讨论FPGA的复位问题，她在一次DEBUG的过程中怀疑FPGA复位不完全，我对此表示不理解，原因是我对FPGA复位的理解不一样：FPGA的复位不像MCU的，它本身是没有复位这种功能的，在FPGA中reset是电路，也就是说你按下reset的按键也只是触发程序中的if(rst)这部分。在这里我打算总结一下复位相关的内容。 复位根据高低电平复位可分为高电平复位和低电平复位目前大多数文章和博客都推荐使用低电平复位，但是没人会告诉你为啥用低电平复位，我在网上找到的一些资料给出的理由无非是如下三种： 1. ASIC设计大多使用低电平复位； 2. 大部分厂家的FPGA使用低电平复位； 3. 低电平复位方式，系统上电时就处于复位状态；关于第二点我有话要说，我不赞成第二种观点，下图是两种器件同步高电平复位的综合结果： 对于Xilinx器件，Spartan6默认的寄存器主要是高电平复位，在ISE的综合结果中，RTL代码使用低电平复位，但是综合后的网表中都会插入一个反相器，而插入反相器会增加组合逻辑电路，组合逻辑电路的增加会导致传输延时增加，进而芯片利用率增加，同时会影响时序和功耗。 如果处于代码复用等考虑而要使用低电平复位，那么可以在系统顶层将复位极性翻转，这样综合器在进行综合的时候会将反相器吸收到IO logic中，不会消耗FPGA内的逻辑和布线资源。 a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 c) Altera Cyclone IV E RTL 原理图 d) Altera Cyclone IV E Technological 原理图 下图是在Cyclone IV E中布局布线之后的结果，对于Altera的器件，Cyclone IV E的寄存器并没有异步复位端，那么使用同步复位的话，综合器会将复位信号综合为输入信号的数据选择信号，这时候就需要额外的逻辑资源了。 To do list： [ ] 1. 芯片利用率受复位反相器添加影响程度到底是多少？之后将进一步尝试。 [ ] 2. 最好有同步复位与异步复位的原理对比 复位根据是否同步可以分为同步复位和异步复位同步复位和异步复位各有优缺点，待我娓娓道来： 同步复位Code： 12345678910111213141516module top_sys ( input wire clk, input wire rst, input wire d, output reg q );always@(posedge clk) begin if (rst) begin q &lt;= 1'b0; end else begin q &lt;= d; endendendmodule a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 c) Altera Cyclone IV E RTL 原理图 d) Altera Cyclone IV E Technological 原理图 优点：1 设计是完全同步，有利于时序分析； 2 因为是完全同步，所以可以降低亚稳态出现的几率； 3 在某些设计中（例如使用锁相环的lock管脚作为），复位信号由内部逻辑产生，推荐使用同步复位，这样可以避免逻辑电路产生毛刺。 缺点：1 不是所有的ASIC库都带有同步复位寄存器，但是这个并不严重，因为同步复位信号只是另一个数据的输入信号，所以综合工具容易把复位信号综合到寄存器外部的逻辑电路中。（待验证） 2 同步复位需要保证复位信号具有一定的脉冲宽度，这点对于系统异步控制产生的复位信号格外重要，例如150MHz模块产生的复位信号输入到50MHz的模块，这点就需要设计同步模块。 3 在仿真中，对于一些基于逻辑表达式计算的仿真器上，一些逻辑可能会阻止复位信号作用到寄存器上。但这是只存在于仿真器的问题，硬件上没有问题。（待验证） 4 同步复位需要时钟处于正常工作状态，这在某些场合就可能有问题，例如：为了降低功耗而选择门控时钟作为模块的控制时钟，在休眠中系统时钟并不工作，若此时同步复位有效，而时钟恢复后复位信号撤销了，那么系统将不能复位。 5 如果设计中含有三态总线，为防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位。（待验证） 6 如果逻辑前进的目标库只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。网上流传的“同步复位会产生额外的逻辑资源”也许指的就是基于Altera的FPGA进行的设计，如下： 但是对于Xilinx的器件，例如我在Spartan6和Zynq7上的实测结果，原语里面已经包含带同步或异步复位的寄存器，所以综合出来的电路并没有“产生额外的逻辑资源消耗”。所以说是否产生额外的逻辑资源消耗关键在于选择怎样的设备，具体问题还要具体分析。 7 类似于时钟信号，复位信号是高扇出信号，最好要加上buffer，一旦复位信号进入到局部逻辑区域，那么就得要限制复位信号到达寄存器所经历的逻辑数量，以减少延迟。 异步复位Code： 12345678910111213141516module reset_async ( input wire clk, input wire rst, input wire d, output reg q );always@(posedge clk or posedge rst) begin if (rst) begin q &lt;= 1'b0; end else begin q &lt;= d; endendendmodule a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 c) Altera Cyclone IV E RTL 原理图 d) Altera Cyclone IV E Technological 原理图 优点：1 几乎所有的库中都包含异步复位寄存器，所以异步复位最大的优点是不需要额外逻辑资源，可以保持数据路径干净，这在数据路径时序紧张时比较管用； 2 脉冲宽度没有限制； 3 没有时钟的时候也可以复位，例如门空电路； 4 EDA工具route起来更容易，对于大型设计能显著减少编译时间；（待验证） 缺点：1 异步电路不利于时序分析，要正确约束异步复位信号比同步复位信号更加复杂；（待验证） 2 异步信号容易受到毛刺的干扰，异步复位信号也一样，系统的毛刺可能产生复位误操作； 3 异步信号最大的问题是复位信号如果产生亚稳态问题，可能导致系统一直无法完成复位；网上的一种说法如下：异步复位最大的问题是容易在复位信号的起效（assert）和失效（deassert）是异步的，起效异步没有问题，但是失效异步可能导致亚稳态。(撤销的时候(release)不满足 removal time 时序要求，从而产生亚稳态)（暂时没太看懂这段，待验证） 对比同步复位电路和异步复位电路的实际结果其实光讲同步复位和异步复位估计大家都不太理解两者的差别，所以我试了一下两者的对比： 仿真波形如下： q1是同步复位电路的输出信号，q2是异步复位电路的输出信号。 1 q1的跳变都发生在时钟上升沿，如2，3所示。 2 q2的复位发生在rst的置位端，如1，4所示；只有当3处在时钟上升沿且复位信号复位的时候，q2才会置位。 所以在drv置位时，输出置位会随着clk信号的上升沿变化；而异步触发器低电平有效，只要rst信号由高变低，输出信号立刻改变，所以信号并未跟着clk信号对齐。 异步复位，同步触发各种复位虽然有各自的优缺点，但是设计过程永远是“两权相害取其轻”，目前很多文章中推荐的大都是一种“异步复位，同步释放”的方法，这种方法可以将两者的优点结合起来。 原理如下所示： 使用打两拍的方式来进行同步 Code： 12345678910111213141516171819202122module SYNC_RST ( input wire clk, input wire rst_pb, output reg sys_rst );reg rst_r;always @ (posedge clk or negedge rst_pb) begin if (!rst_pb) rst_r &lt;= 1'b1; else rst_r &lt;= 1'b0;endalways @ (posedge clk or negedge rst_pb) begin if (!rst_pb) sys_rst &lt;= 1'b1; else sys_rst &lt;= rst_r;endendmodule 综合后的电路图： 关于这个异步处理的方法和优点，请参考另外两篇博文： 1 异步时钟信号同步化及其综合结果 2 亚稳态的产生和对应策略 结论1. 尽可能使用同步复位，保持设计的“同步化”； 2. 如果器件本身带有同步复位端口，那么直接使用同步复位，Xilinx就是个典型案例； 3. 如果不带同步复位，那么使用异步复位时必须包含同步器。在详细讨论了各种复位方式之后接下来将介绍一些使用过程中常遇到的场景 不适合复位的场景组合逻辑电路组合逻辑电路不要加上复位，因为组合逻辑电路本身是没有“记忆”这种特性的，也就是说不需要复位的过程来让其“失忆”。如下实验，综合器在综合的过程中将rst信号综合进了输入信号，最终成为了数据选择器。 Code： 12345678910111213141516module reset_sync ( input wire clk, input wire rst, input wire d, output reg q );always@(*) begin if (rst) begin q &lt;= 1'b0; end else begin q &lt;= d; endendendmodule a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 移位寄存器不是所有的寄存器都需要复位。移位寄存器就是一个典型的例子，移位寄存器只需要复位第一个寄存器，后续的触发器仅作为数据寄存器使用。这里体现的一个原则就是：reset能省则省。因为reset往往跟clk同时出现，但是FPGA中有时钟树用于时钟优化，但是没有复位树优化复位信号（待查？？是否有reset distribution tree），所以对于拥有大量扇出的reset信号，很容易造成route难度上升，性能下降，编译时间增加。 比较好的设计风格，不同类型的寄存器不应该组合进同一个always块，最好的风格应该是只对一种寄存器建模。 不好的代码风格Code： 12345678always @(posedge clk) begin if (rst) begin tmp &lt;= 1'b0; end else begin tmp &lt;= d; q &lt;= tmp; endend 综合后的原理图： a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 复位信号对于第二个寄存器来说是一个片选信号，rst在这里有两个扇出。 好的代码风格Code： 12345678910111213141516171819module good_codestyle ( input wire clk, input wire rst, input wire d, output reg q );reg tmp;always @(posedge clk) begin if (rst) begin tmp &lt;= 1'b0; end else begin tmp &lt;= d; endendalways @(posedge clk) begin q &lt;= tmp;endendmodule 综合后的原理图： a) Xilinx Spartan6 RTL 原理图 b) Xilinx Spartan6 Technological 原理图 复位信号与第二个寄存器没有连接，可以看到第二个寄存器减少了一个扇出信号。 多时钟复位在一个系统中，往往有多个时钟，每个时钟域都应该有独立的同步器和复位，如果使用系统复位，各时钟域复位与系统复位的关系就为异步复位，而异步复位可能导致的亚稳态问题会对系统的稳定性造成影响。 全局同步复位对于大多数多时钟域系统，不同时钟域之间的复位信号并没有先后要求，尤其是在request-acknowledge这样的握手信号系统中，不会引起硬件上的误操作，这时候全局同步复位即可。 How do I reset my FPGA 在文中提供了一张图来说明典型的系统复位方案，图中 MMCM 的 lock 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。 顺序复位对于部分对复位有要求的设计，复位信号的释放顺序有一定的要求，此时要使用如下的方法： 复位毛刺滤波异步复位系统对毛刺比较敏感，下图是一种系统中处理毛刺的方法，简单粗暴，但是据说比较丑陋？！(时延不是固定的，会随温度、电压变化) 需要注意的是 1. 毛刺 Glitch 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论见《锁存器与竞争冒险》 2. 不是所有的系统都需要过滤毛刺，设计者要先研究需求，再觉得是否使用延时来过滤毛刺总结1. 复位方式应该根据具体使用哪种器件决定，Xillinx推荐使用高电平复位，Altera的器件推荐使用低电平复位； 2. 尽可能使用同步复位，保持设计同步化，如果器件本身带有同步复位，请直接在RTL代码中使用同步复位，如果器件不带同步复位端口，那么就需要一部复位同步化； 3. 每个时钟域都应该有一个同步器来同步复位信号；参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use? Asynchronous &amp; Synchronous Reset Design Techniques - Part Deux Get Smart About Reset: Think Local, Not Global How do I reset my FPGA FPGA复位电路的实现及其时序分析 深入浅出玩转 FPGA 100 Power Tips for FPGA Designers Advanced FPGA Design by Steve Kilts FPGA 的复位 Asynchronous reset synchronization and distribution Special cases FPGA 中的复位设计]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>异步时钟</tag>
        <tag>电平同步</tag>
        <tag>复位</tag>
        <tag>器件特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步时钟信号同步化及其综合结果]]></title>
    <url>%2F2018-07-16%2Fasync-clock-sync%2F</url>
    <content type="text"><![CDATA[异步时钟处理是每个使用FPGA的工程师都必须要掌握的技巧。可以说，如果你不会处理异步时钟信号，那么我会认为你压根儿就没用过FPGA。这里总结了三种常见的异步时钟处理方法，并且在仿真中验证过。 通常使用 MTBF (Mean Time Between Failures) 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×10^9 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。 理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。 如图所示： 图1 同步器结构 通常，同步器由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。 为了让同步器正常工作，从某个时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入同步器。之所以这样要求，是因为同步器的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过同步器，给新时钟域后续逻辑一个虚假的信号。 同步器有很多设计方法，因为一种方法不能满足所有的应用需求。同步器的类型基本上分为 3 种： 1. 电平同步器 2. 边沿检测同步器 3. 脉冲同步器下面分别讨论： 电平同步器Schematic: 图2 电平同步器结构 电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 paper 中有更详细的图解说明： 图3 电平同步器详细介绍 Code:123456789101112131415161718192021222324252627282930module LVLSYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output reg dat_dst );// source time domainreg dat;always @(posedge clk_src) begin if (rst_src) begin dat &lt;= 1'b0; end else begin dat &lt;= dat_src; endend// destination time domainreg dat_r;// using two level DFF to synchronize the din_qalways @(posedge clk_dst) begin if (rst_dst) begin dat_r &lt;= 1'b0; dat_dst &lt;= 1'b0; end else begin dat_r &lt;= dat; dat_dst &lt;= dat_r; endendendmodule RTL: 图4 电平同步器RTL图 SIM: 图5 电平同步器仿真图 Restriction:使用电平同步器的要求是： 1. 源时钟域的信号应先通过源时钟域的一个 DFF 后输出，然后直接进入目的时钟域的同步器的第一级 DFF。这么做到原因是：同步器的第一级 DFF 对组合逻辑产生的毛刺（glitch）非常敏感。如果一个足够长的毛刺刚好满足了 setup/hold time，那么同步器会将其放行，产生一个虚假的信号。 2. 跨域时钟域的这个信号持续时间 &gt;= 2 个新时钟域时钟周期。虽然 Crossing the abyss: asynchronous signals in a synchronous world 中是这么写的，但是我觉得这个条件应该是保险条件，而不是最低条件。 电平同步器的最低条件应该和边沿检测同步器相同： 输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。 首先，待同步到信号宽度 &gt; 源时钟周期，这样它才能被源时钟域的 DFF 采样到，然后输出； 其次，源时钟域采样输出端信号的宽度当然是源时钟周期的整数倍，它的宽度 &gt; 目标时钟域周期 + 第一个 flip-flop 的 hold time，这样它才能被目的时钟域的时钟采样到，然后进行同步。 所以，保险一点的条件是：待同步到信号有效时间至少是目的时钟周期的 2 倍。电平同步器是其他两种同步器的基础： 边沿检测同步器边沿检测同步器 是在电平同步器的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。 Schematic: 图6 边沿检测同步器结构 Code:123456789101112131415161718192021222324252627282930module EDGESYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output wire dat_dst );// source time domainreg dat;always @(posedge clk_src) begin if (rst_src) begin dat &lt;= 1'b0; end else begin dat &lt;= dat_src; endend// destination time domainreg [2:0] sync_reg;always @(posedge clk_dst) begin if (rst_dst) begin sync_reg &lt;= 3'b0; end else begin sync_reg &lt;= &#123;sync_reg[1:0], dat&#125;; endend// AND to get the outputassign dat_dst = sync_reg[1] &amp;&amp; (~sync_reg[2]);endmodule RTL: 图7 边沿检测同步器RTL图 ###SIM: 图8 边沿检测同步器仿真图 Restriction:使用边沿检测同步器的要求是： 1. 输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。实际上，因为在源时钟域，要先用 DFF 寄存一下再输出，所以源时钟域输出的信号的宽度是其时钟周期的整数倍，它肯定是 &gt; 目标时钟周期的，因为边沿检测同步器只能工作在慢时钟域到快时钟域的情况下。边沿检测同步器在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用脉冲同步器。 脉冲同步器脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。源时钟域的单时钟宽度的脉冲不是直接输出的，而是先经过一个源时钟域的翻转电路。这个翻转电路在每次输入一个脉冲时，它的输出会在高、低电平之间翻转。而在目的时钟域，翻转电路的输出先通过一个电平同步器，其输出到达异或门的一个输入端，而这个输出再经过一个 DFF，延时一个时钟周期后进入异或门的另外一个输入端。最后异或门的输出即最终的同步结果：源时钟域每有一个单时钟脉冲（源时钟），同步器的输出端产生一个单时钟宽度（目的时钟）的脉冲。 Schematic: 图9 脉冲同步器结构图 Code:123456789101112131415161718192021222324252627282930313233module EDGESYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output wire dat_dst );// source time domainreg toggle_reg;always @(posedge clk_src or posedge rst_src) begin if (rst_src) begin toggle_reg &lt;= 1'b0; end else begin if (dat_src) begin toggle_reg &lt;= ~toggle_reg; end endend// destination time domainreg [2:0] sync_reg;always @(posedge clk_dst) begin if (rst_dst) begin sync_reg &lt;= 3'b0; end else begin sync_reg &lt;= &#123;sync_reg[1:0], toggle_reg&#125;; endend// XOR to generate the pusle_dstassign dat_dst = sync_reg[1] ^ sync_reg[2];endmodule RTL: 图10 脉冲同步器RTL图 SIM： 图11 脉冲同步器仿真图 Restriction:使用脉冲同步器的要求是： 1. 输入脉冲之间的最小间隔 &gt;= 2 个同步时钟周期。如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻，形成一个比单时钟周期宽的输出脉冲。 实际上，在一些情况下，少于 2 个时钟周期（&gt; 1 个时钟周期）也是可以同步上的。只要同步器的两个 DFF 的值不一样即可同步上，也就是说异步信号在连续的两个目的时钟采样的值不同即可，由于异步信号和时钟的相位关系不确定，所以在没有对齐的情况下，大于 1 个时钟时也能满足两个采样值不同的条件。 一般为了保险起见，要求其保持至少两个时钟宽度。时钟消耗同步器需要花费 1～2 个时钟周期来完成同步，所以粗略的估计可以认为同步器会造成目的时钟域的 2 个周期的延迟，我们在设计时需要考虑同步器对时序产生的影响。 总结总结3种同步器的特点，有下表： 图12 三种同步器的优缺点比较 虽然还有其他类型的同步器，但是这 3 种基本上就可以解决设计中遇到的多数问题了。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 跨越鸿沟：同步世界中的异步信号 cpu与fpga跨时钟域数据交换的实现问题 FPGA 时钟设计 3 —— 跨时钟域设计 跨时钟域设计的一点总结 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>异步时钟</tag>
        <tag>电平同步</tag>
        <tag>边沿检测同步</tag>
        <tag>脉冲同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竞争与冒险]]></title>
    <url>%2F2018-07-11%2Frace-competition%2F</url>
    <content type="text"><![CDATA[在数字电路设计时，无论是组合、时序，还是 FPGA 电路中，都需要考虑竞争冒险现象（Race and Competition）。在这里对竞争冒险现象稍微整理了一下。 概念 竞争：门电路两个输入信号同时向相反的逻辑电平跳变（一个从1变成0，另一个从0变成1）的现象称为竞争（Race）。 冒险：由于竞争而引起电路输出信号中出现了非预期信号，产生瞬间错误的现象称为冒险（Risk）。表现为输出端出现了原设计中没有的窄脉冲，常称为毛刺（Glitch）。 关系：有竞争不一定产生冒险，但有冒险就一定有竞争。 分类：竞争分为临界竞争和非临界竞争。冒险分为静态冒险和动态冒险。 临界竞争：产生暂时或永久性错误输出。 非临界竞争：没有导致冒险发生，或虽有冒险发生但不会产生错误输出，不影响系统的工作的竞争。 静态冒险： 输入信号变化前后，输出的稳态值一样，但在输入信号变化时，输出信号产生了毛刺。在组合逻辑电路中，由于产生冒险的原因不同又分为功能冒险和逻辑冒险。 0险象0险象指的是组合逻辑的初识输出为0，当其输入改变时，若新输入对应的输出仍应该是0，却在输出端出现了短暂的不为0的情况。 1 险象1险象是指组合逻辑的输出初始值为1，当其输入改变时，若新输入对应的输出仍应该是1，却出现了短暂不为1的情况。 动态冒险： 输入信号变化前后，输出的稳态值不同，并在边沿处出现了毛刺，即输入变化输出应变化的情况下，输出在变化的过程中产生了短暂的错误输出的现象。 01 险象01 险象，是指组合逻辑初始输出为0，当其输入改变时，对应新的输出应该为1，本来输出只应该出现一次从0到1的翻转，但实际中却出现了多次的0,1翻转情况。 10 险象当输入端从1变化到0时候，由于下半部分延迟较大，所以与类型半开关先传递了上半部分的静态1险象后，再传递下半部分，输出恒为0，形成了10险象。 产生原因:组合逻辑电路中，产生竞争冒险的主要原因是时延。时序逻辑电路中，产生竞争冒险的原因主要有两个方面： 组合逻辑电路部分可能发生的竞争冒险现象。 存储电路工作过程中发生的竞争冒险。同步时序电路不存在竞争现象。 异步时序电路中，当输入信号和时钟信号同时改变是，而且是通过不同路径到达同意触发器时，就有可能导致竞争冒险。FPGA 中：在 FPGA 中，延时主要是由连 线的长短和逻辑单元的数目决定的，同时还受器件的制造工艺、工作电压、温度等因素影响。信号的电平转换也需要一定的过渡时间。由于 FPGA 以及其他的 CPLD 器件内部的分布电容和电感不能过滤电路中的毛刺，从而使得毛刺逐级传递，对电路早晨的影响更加突出。即使是在最简单的逻辑运算中，如果出现多路信 号同时跳变的情况，在通过内部走线以后，也一定会产生毛刺。 检查方法代数法在输入变量每次只有一个改变状态的简单情况下，可以通过逻辑函数式判断组合逻辑电路中是否有竞争—冒险现象存在，具体方法如下： 在逻辑函数式中将n-1个输入变量（共n个输入）用固定的0或1带入，最后能将逻辑函数式能化简成 Y = A + A’ 或 Y = A · A’ 或者上面两式的反 Y’ ，即可判定存在竞争—冒险现象。 补充：由上述判定可以得知，只要电路中的与门和非门的两输入同时向相反的逻辑电平跳变（一个从1变为0，另一个从0变为1），就存在竞争—冒险现象。 卡诺图法有两个相切的卡诺圈，并且相切处没有其他卡诺圈包围，可能会出现竞争-冒险现象。 另外，较为复杂的情况而采用计算机辅助分析+实验的分析方法。 消除方法接入滤波电容在输出端并接一个很小的滤波电容，就足以把尖峰脉冲的幅度削弱至门电路的阈值电压以下。 优点：简单易行； 缺点：增加了电压波形的上升时间和下降时间，使波形变坏； 适用：对输出波形前、后沿无严格要求。 引入选通脉冲在电路中引入一个选通脉冲p，p的高电平（正脉冲）出现在电路到达稳定状态以后，这时正常的输出信号也将变成脉冲信号，且宽度与选通脉冲相同。 优点：简单，不需要增加电路元件； 缺点：需要设法得到一个与输入信号同步的选通脉冲，对其宽度和作用的时间也有严格要求。 修改逻辑设计(代数法or卡诺图法)例：逻辑函数式 Y= AB + A’C ，在B = C = 1的条件下，当A改变状态时存在竞争—冒险现象。通过增加冗余项的方法，函数式可变为 Y= AB + A’C + BC ，此时在B = C = 1的条件下无论A如何变化，输出始终保持Y = 1，即A的状态改变不再会引起竞争—冒险现象。 优点：不会给电路带来不利的影响； 缺点：无法消除多变量同时改变状态时，例如AB从10变为01电路仍会存在竞争—冒险的现象，且该方法适用范围有限； 上述方法适用于消除单变量改变状态时存在竞争—冒险现象的情况。 因为时序逻辑电路中通常包含组合电路和存储电路两个部分，所以它的竞争—冒险现象包含两个部分。 下图是一个实际的工程案例： 在逻辑函数式 Y= AB + A’C ，在B = C = 1的条件下，输入变量A从1跳变到0时会产生毛刺。 将逻辑函数式修改为 Y= AB + A’C + BC 后，在B = C = 1的条件下，无论输入变量A如何跳变都不会产生毛刺。 但是由于FPGA是基于查找表结构的，也就是说对于FPGA来说，它会把ABC看做查找表的三个输入，Y看做输出。也就是说对于这个工程，输出其实不会产生的毛刺，但对于更大的工程，工程中包含多个LUT时就有可能产生毛刺，正式的情况也比这个要复杂很多。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 FPGA中竞争冒险问题的研究 关于冒险和毛刺 组合逻辑设计中的毛刺现象 组合、时序逻辑电路中的竞争—冒险现象 组合逻辑中的竞争与险象问题 FPGA 竞争与冒险 Hazards in Combinational Logic 竞争与冒险 Hazards and Glitches Hazards/Glitches and How to Avoid Them]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA进阶款</category>
      </categories>
      <tags>
        <tag>竞争</tag>
        <tag>冒险</tag>
        <tag>毛刺</tag>
        <tag>代数法</tag>
        <tag>卡诺图法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wire and Reg等定义的综合结果]]></title>
    <url>%2F2018-05-04%2Fwire-reg%2F</url>
    <content type="text"><![CDATA[在我刚开始使用ISE的时候，阻塞赋值和非阻塞复制让我头疼了很久，倒不是不理解这两种赋值方式，而是不理解组合逻辑电路和时序逻辑电路的设计本质。今天来稍微总结一下： reg型凡是在always块中进行赋值，变量一定得要是reg型，但是这并不意味着所有用reg的变量一定会综合成时序逻辑电路。比如： 12345678910always@(posedge clk) begin if (rst) begin data &lt;= 2'b00; end else begin if (addr == 2'b00) data &lt;= 2'b11; else if (addr == 2'b11) data &lt;= 2'b00; endend 1234567always@(*) begin case(addr) 2'b00: data &lt;= 2'b11; 2'b11: data &lt;= 2'b00; default: data &lt;= 2'b10; endcaseend 这里的两段代码中data都被定义为reg，但是综合结果却完全不一样，第一段代码会综合成时序逻辑电路，data会综合成FF，第二段代码会综合成组合逻辑电路，data会被综合成导线。 wire型而assign语句只能使用wire型进行赋值： 12345678910module test_ifelse( input wire clk, input wire rst, input wire [1:0] addr, output wire [1:0] data );assign data = addr + rst;endmodule PS：同样在always@（*）块中，ISE会对 data=2’b00 语法报错，而Quartus不会报错，这点需要注意！]]></content>
      <categories>
        <category>FPGA血泪史</category>
        <category>FPGA入门款</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>变量定义</tag>
        <tag>Wire</tag>
        <tag>Reg</tag>
        <tag>实际电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程存档文件夹命名]]></title>
    <url>%2F2017-08-13%2Ffolder-manage%2F</url>
    <content type="text"><![CDATA[对于我这种强迫症，工程管理都做了，那怎么能不顺便做一下文件夹的命名管理呢？奸笑 我的工程文件夹使用扁平化的存放形式，那是因为我不喜欢文件夹套文件夹的存放方式，一级地找文件就像是在迷宫中找出口一样复杂。 AA_Buf: 临时存放，之后需要整理 BB开头的文件夹代表上位机软件相关(binary的简称)： BT开头的文件夹代表已编译的可执行文件 T代表Tool BXX代表含源码的工程，B后的两位代表编程语言，例如BCC就是使用C语言的工程 #由于编程语言较多，程序语言使用双字编码，其中： CC：C语言； CS: C#； CP: C++； VR: Verilog ； VH: VHDL UU: 不确定 JS: Json JV：JAVA VB：Visual Basic； BT:批处理指令； MT：Matlab； JS:Jason； CP:Citespace; BXXR代表含源码的参考工程，注释同上 BSYS代表操作系统 PET:petalinux； AND：安卓； UBN：Ubuntu 后面加上版本号，例如： BSYS_PET_1704_FullBioSignal_Phase2CC开头文件夹代表结构设计相关： 第二个字母代表模型格式 S: SOLIDWORKS; C: CREO; A: AUTOCAD的DWG,DXF文件； D: PDF; T: STEP 同一个文件夹中若同时包含几种模型格式，则按照SAC顺序排序 第三个字母代表模型用途 R:参考设计（Reference）； D：草稿（Draft）； L：库（Library）； E：PCB模型，用于和结构工程师交互； S：仿真（Simulation）。 第四个字母代表模型库的细分类 P:泵（PUMP）； V:阀（Valve）； J:接头（Junction）EE开头的文件夹代表PCB工程 EX_板号_XXX_RX 电子设计的工程文件,尾缀是版本号，R是状态，R代表原型设计，D代表设计 EXL_XXX 某个项目的临时库 EXR_XXX 电子设计的参考设计 其中，使用一个字母表示文件格式： C:Cadence； A：Altium； P：PADS； D：PDF； E：Eagle； X：EE； G：GERBER 如果有多个文件的，按照CAPDEXG的顺序取第一个字母。FF开头的文件夹代表固件相关(firmware的简称)： FXX代表含源码的工程，F后的两位代表编程语言，但是之后需要加上主芯片和IDE的代号. 例如FCC_430_I_XXXX就是使用C语言的工程，主芯片为430，IDE为IAR Xilinx ： SP7：Spartan-7； AX7：Artix-7； ZQ7：Zynq-7； KX7：Kintex-7； Altera： AA10：Arria-10； MX10：Max-10； SR10：Stratix-10； CY10：Cyclon-10. #由于编程语言较多，程序语言使用双字编码，其中： CC：C语言； CP: C++； VR: Verilog ； VH: VHDL UU: 不确定 #IDE代码： I: IAR K: KEIL C: CREATER A: ANDES H: HOLTEK U: 无IDE S: SILICON STUDIO V: VIVADO Q: QuartusII S: ISE 如果有多个IDE的，按照KIUCHAS顺序排序 FXXR代表含源码的参考工程，注释同上 FXXL_MAIN-IC_LIB_VERSION 存放官方的库文件，例如STM32和EFM32的库，但是TI提供的却只是例程，不算是库。 另外，我自己写BSP暂时不进行归档处理，因为各种硬件差别比较大，所以也没必要做通用适配，等要用到的时候再复制即可。RR开头的文件夹代表网上下载的资料文件(reference的简称)： R后面可以有第二个字母用来对内容进行细分,比如： RD开头的文件夹代表设计思路相关(design的简称)： RP开头的文件代表有详细文件的参考工程 RC开头的文件夹代表结构参考工程 RCX_开头的文件夹代表某大类结构件相关规格书，例如RCP代表的就是泵,其中: P: 泵； V: 阀； RE开头的文件夹代表电子相关资料： REX_开头的文件夹代表某大类电路元器件, 例如REC代表的就是电容 细分类同原理图库 规格书格式 厂家名_型号_功能描述 RS开头的文件夹代表仿真相关资料 RSX_开头的文件夹代表相应工具的参考资料，例如RSC代表的就是PSPICE的相关资料,其中: C：Cadence（Pspice）； S：Saber；MM开头的文件夹代表生产相关的文件，需要特别注意别弄混 M_XXX 指向的是某个项目的具体加工或报价或采购记录，内容可以考虑用压缩包的形式样品采购文件夹存放采购相关信息，主要是单独物料采购，供货商的样品采购。 一定要加上供货商的详细信息。SS开头的文件夹代表仿真相关文件，仿真用的文件，特别需要注意删除一些不是很重要的仿真结果，免得占地方,不需要在所有客户端都进行同步，这些可以使用Git进行管理 第二个字母代表仿真内容： C：结构； E：电子相关； H：热力学仿真 第三个字母代表仿真工具 A：ANSYS相关软件； C：Cadence； L：LTSPICE； S:Saber； M：Comsol； T:TINA 第四个字母L代表相关软件的库TT开头的文件夹代表测试数据，测试报告等文件，不需要在所有客户端都进行同步 T_WM_XXXXXX_具体内容 实验数据和实验报告的命名方式可能还得再考虑考虑 图片类的实验数据要写明是做什么用的VV开头的文件夹存放音频和视屏文件，用于存放极其重要的音视频文件，这个比较占地方，需要及其注意 ZzRubbish文件夹用来存放没什么用可以删掉的资料 最后来一张效果图：]]></content>
      <categories>
        <category>强迫症专题</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>工程存档</tag>
        <tag>扁平化命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git管理工程的方法]]></title>
    <url>%2F2017-08-07%2Fuse-git%2F</url>
    <content type="text"><![CDATA[Git是当下最流行的工程管理方法，作为一个硬件工程师，也得要跟上时代的脚步，努力学习其他行业的技术优点。在了解了Git之后，发现它是当之无愧的神器，用Git就是爽，一直Git一直爽！ 首先讲一下为啥要用Git 不使用Git 使用Git Git特别适合代码这种试错成本低，迭代快速，带有尝试性质的场合。 简单讲一下Git， Github，SVN之间的联系与区别Git和SVN都是一种文件管理方式：Git是基于分布式库管理设计的，在本机上会有一个仓库，同时，也可以在云端有一个仓库，所以没有服务器端其实也可以提交和版本备注；SVN是集中式管理的，仓库直接上传到服务器端，没有服务器端就基本上用不了。GitHub是众多基于Git技术的管理服务器端之一，他们做的基于Git的客户端工具叫做GitHub-Desktop。此外，还有Sourcetree，GitKraken等。 所以，正确的层次结构应该是这样的： 项目管理技术服务器客户端 GitGitHubGitHub-Desktop AtlassianSourceTree GitKrakenGitKraken GitLab无 无TortoiseGit 无Git（Git原生的客户端） SVN没了解过没了解过 PS： 1. 以前免费版的GitHub账户只能创建公开仓库，自从巨硬收购了GitHub后，现在免费版账户也能创建私有账户了。 2. Git的项目文件夹可以用上述任何一款客户端打开和编辑，他们是标准格式，不会有冲突。 3. 虽然有些Git客户端会自带Git控制台，但是不建议把这种Git控制台用作全局使用，因为他们的路径名称中有软件自己的名字和版本号，更新几次后会导致路径名失效。实验室用群晖搭建了GitLab，接下来就让咱们来试用一下吧 准备工作：1.git客户端1.产生gitlab服务端和本地git相互传输时所需要校验的私钥和公钥 2.直接在Idea中使用git提交和push代码，当然也可以用sourcetree提交代码 2.sourcetree客户端1.拉取远端服务器代码到本地 2.push本地代码到远端 3.创建分支，解决提交代码中的冲突 3.gitlab账号（一般公司配置，用自己的邮箱）1.建立远端分支，可追踪 2.本地和远端代码的修改活动详细显示 3.云储存库，储存代码 一句话就是gitlab中存储着远端的代码，git是本地代码和远端代码沟通的桥梁，不过是用命令行的形式，sourcetree是将git变为可见的客户端。 软件安装（以SourceTree为例，其他软件类似）：1.安装git客户端（Git-2.14.0-64-bit.exe）一路Next，但是最后一步有一个是否允许符号链接的勾，按照个人需要选择。不管你选没选，我反正是选了。 2.安装SourceTree（SourceTreeSetup-2.1.2.5.exe） 需要申请一个账户（反正也免费，申就申吧），一路Next。假如GitHub上已经有库的话就可以在这个时候同步下来，没有的话也没关系，反正之后要再建的。当问及是否要创建SSH的时候选否吧，反正之后要手动创建的。 在windows下安装时，当需要使用内置的git，hg时，需要从atlassian.com网站下载。不知道什么原因，总是下载失败。使用Chrome是能够自己下载这两个文件的。使用代理也不好用。所以只有自己下载之后，放在这个目录下，才会好用。 c:\users\YOURUSERNAME\AppData\Local\Atlassian\SourceTree, 把下载好的压缩包解压缩到这个目录下。Git对应git_local,HG对应hg_local。这样就可以在SourceTree中设置使用内置的git和hg了。 另外，需要下载的压缩文件的URL可以在这个目录下的sourcetree.log中找到。下载失败之后会在这里纪录URL。 3.至此软件安装完毕使用SSH链接GitLab：1.利用git bash生成公钥和私钥（使用git bash命令生成gitlab服务端和本地git相互传输时所需要校验的私钥和公钥，公钥用于配置gitlab，私钥用户配置sourcetree。） 打开git bash,输入以下命令： （1）设置git的user name和email：12$ git config --global user.name "test"$ git config --global user.email "test@gmail.com" （2）生成SSH密钥过程：1.查看是否已经有了ssh密钥： 1cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 2.生成密钥：（注意ssh与参数之间没有空格！！！） 1$ ssh-keygen -t rsa -C “邮箱地址” -C 选项后是备注，可随意。命令执行后会要求输入key存储的文件名和passphrase： • 输入一个特有的文件名，否则使用默认的 id_rsa。 • passphrase。不输入也可以。输入之后，提交的时候要输入这个passphrase完成后在 ~/.ssh/ 会生成2个文件。id_rsa 和 id_rsa.pub。前者是私钥，注意保管，后者是公钥。在这里按3个回车，密码为空就可以了。 此时在.ssh文件夹下回生成下面3个文件， 2.在gitlab中配置公钥登录gitlab-&gt;project setting-&gt;SSH,添加即可 打开id_rsa.pub，把内容复制进去 显示如下就OK了 3.sourceTree配置的私钥，与gitlab公钥对应打开sourcetree,点击工具》选项》一般，设置公钥的路径即可。注意客户端选择：OpenSSH 在GitBash中ping一下试试 这样就可以配置成功了！！！ ———————————-华丽丽的分割线———————————- 4.拉取远端代码到本地仓库在gitlab中寻找需要拉取的仓库地址，如下： 在sourcetree中，选择克隆/新建仓库，填写远端和本地的仓库路径，添加即可，之后直接pull 仓库即可。 这样以后可以直接在sourcetree拉取代码了。这里的URL格式需要修改如下： 注意，这次实验使用的端口是8022，具体出现问题的话可以问问我。 Git管理Keil工程：其实很简单，建立仓库后直接把对应的.gitignore文件和工程文件放到Git仓库中，就可以进行commit和push了。 Gitserver建立git仓库的方法群晖的Gitserver不支持通过SSH来登录，所以最好找一个支持账户密码存储的客户端T_T 下面是记录群晖Gitserver创建仓库的方法，以后写个脚本让他自动装机创建吧。 123456789101112cd /volume1/git_reposmkdir xxxx.gitcd xxxx.gitgit init --baresudo -i // 取得root权限cd /volume1/git_repos/chown catonblack:users . // 将gitReposTest目录的所有者改为管理员账户aulati，目录的所属群组改为users。注意不要忘了[.]chmod 770 . // 将gitReposTest目录的所有者、所属群组的权限改为 读/写/运行chown -R git:users xxxx.git // 改变test.git目录及所有包含文件、子目录的所有者chmod -R 770 xxxx.git // 改变test.git目录及所有包含文件、子目录的权限git clone ssh://git@192.168.3.5:9022/volume1/git_repos/test.git 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 漂亮的git分支图 Keil-MDK 使用 Git 作为项目版本管理工具 Keil协同开发存在的问题 Git管理Keil工程实录 解决 需要生成 多个SSH key 的问题]]></content>
      <categories>
        <category>工具使用技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Gitlab</tag>
        <tag>GitHub</tag>
        <tag>GitServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于中心库的NAS,云盘和Git的文件管理方式]]></title>
    <url>%2F2017-08-03%2Ffile-manage%2F</url>
    <content type="text"><![CDATA[对于我这种重度强迫症患者来说，多台PC间、以及多个项目间的文件管理一直是令我抓狂的地方。所以最近抽了一段时间来进行文件的整理，研究了一下Git、云盘以及符号链接的特性，并根据自己的使用习惯进行了设计。这里将这部分经验分享一下。 以下内容适合有多台PC的Windows用户，只有一台PC（以后也不会同时用多台PC）的人可以不看了，用MAC的土豪不用看了，因为没在MAC上试过（估计也不行），用Linux的人也不用看了，理由同上。 与其说是NAS,云盘和Git的使用心得，不如说是建立了一套基于中心库的文件管理方式。 背景：假设有四台电脑：第一台台式机，放在办公室作为主力PC；第二台台式机，放在实验室用于调试；第三台台式机，放在家里；第四台笔记本，随身携带。开始蛋疼了： PC1： C:30G D:200G E:200G F:1.5T PC2： C:60G D:200G PC3： C:256G D:256G E:150G F:500G G:1.5T PC4： C:512G蛋疼点1：假如在办公室改的图纸，要拿到实验室去调，发现一些问题需要晚上拿回家再改，那样就得需要用个U盘从这台PC拷到另一台PC，拷来拷去，如果中间还需要修改和添加批注的话，时间一长，自己也很有可能不知道哪个文件是哪个版本。。。 蛋疼点2：假设AD指向的库目录没法一致，例如PC1指向的是D盘，PC3指向的是G盘，PC4指向的是C盘。那么当把一个项目从PC1拷到PC3的时候就会出现一大堆弹窗，通知你没找到库，然后就得一个个手动添加，AD指向的库目录有的还特别深，感觉整TM不爽。。。 蛋疼点3：如果各个项目之间有交叉有耦合，例如项目1里面的器件可以在项目2里面用，在项目1的规格书里添加了备注，这时候项目2开始了，可以把项目1的文件复制到项目2，之后又在项目2中添加备注，多次往复添加的备注就会不一样，时间一长铁定遗忘。 蛋疼点4：使用Onenote和Endnote的时候，不建议直接将文件附件直接插入，理由同上，会导致同一个文件有多个版本，内容会不一致；也不建议直接打印到笔记本里，因为Onenote会打印成图片，小的文件还好，大的文件就会大大增加Onenote的体积，3M的PDF就可能会变成100M+的图片，十分蛋疼。这种时候就建议有一个指向链接，链接到相应的文件，而假如在不同的电脑上链接的位置不一样就又会导致蛋蛋火辣辣地疼。 蛋疼点5：如果直接使用NAS等网盘工具进行同步的话，需要同步的代码编译出来的一大堆文件不光占地方，而且极容易导致同步冲突。虽然可以添加文件例外，但是不同项目有着不同的要求，每一个都不太一样，无法使用通用的文件例外适配所有程序。 蛋疼点6：有些文件不希望他实时同步，例如Comsol的文件，结果会存在mph文件中，使得文件特别大，这种文件一般是希望把结果删掉之后再保存的，不然的话，一下子就好几个G，没有哪个网盘可以HOLD住的。 ———————————————-还要用，所以不割———————————————— 首先要大致介绍一下符号链接：这东西就类似于指针，假设把G:\Lib指向C:\Lib，文件的位置依然在G:\Lib，但是操作C:\Lib中的文件也会有同样地更改，这点类似于快捷方式。但是它不同于快捷方式的地方在于： 1. 快捷方式其实是一个.INK的文件，使用资源管理器打开；符号链接只是一个指向链接，由操作系统调度。 2. 其他软件中是无法打开快捷方式的，但是可以打开符号链接。 3. 复制快捷方式得到的还是快捷方式，但是复制符号链接得到的是源文件。例如你复制C:\Lib，其实得到是G:\下的文件。Git的介绍再另一篇里有，在此不再赘述。 —————————————————可以割了—————————————————- 接下来就是见证奇迹的时刻如下图所示，所有文件夹的真实位置在G盘根目录下，先将所有目录在C:/CentralLib中进行重新分配，尽可能设计成扁平化的文件夹风格。因为每台windows电脑肯定有C盘（什么？你的windows装在了D盘！好吧，你牛X），这样就让系统误认为所有文件都在C盘。然后从C盘将文件分别映射到E:/Work下的各个工程文件夹，这样就能保证不同的工程文件夹后来用的是同一套库了。 特点： 网盘适合同步几十K~几十M的文件，最好是不会产生大量临时文件的那种，即使产生临时文件也是可以随时删掉而不会对文件造成影响。例如PDF,OFFICE文档，pcb文件，压缩后的工程存档。 NAS因为是内网，所以同步速度特别快，除了对网盘文件进行同步以外，还可以对一些临时性的文件进行快速同步，以免文件丢失。例如网上下载到的参考固件，网上下到的一些小工具等。 GIT适合对二进制文件同步，因为它每次只上传修改后的部分，而且可以手动调整分支，可以指定上传的文件。这些性质对于代码，仿真这种可能会有多种分支，试错成本又低的场合是非常合适的。 使用符号链接，在C盘创建一个虚拟的中心库，然后再将工作盘和其他文件指向这个中心库，原始文件则可以按照各自最合适的方式进行同步。 没有适配所有文件的同步方式，建议使用各自最合适的同步方式来同步。 当项目需要存档和打包的时候，直接复制就可以了，复制符号链接得到的是源文件。 2019-03-01 更新最近确定硬盘挂了，在酿成大错之前赶快备份数据，这时候之前的符号链接让我犯难了，不能直接copy，这样的话会将源文件直接复制过去的，所以这里用了xcopy指令。 复制包含符号链接的目录： 1xcopy e:\test j:\test /e /B 源 e:\test 目标 j:\test]]></content>
      <categories>
        <category>强迫症专题</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>NAS</tag>
        <tag>云盘</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泡面鉴赏]]></title>
    <url>%2F2017-03-01%2Finstant-noodles%2F</url>
    <content type="text"><![CDATA[某日心血来潮，想要研究一下比较著名的进口泡面，于是就通过万能的淘宝买了一些进行品鉴。不得不说，买家秀和买家秀的确差异蛮大的，在这里记录一下，以备以后查阅。 在开始前，本次品鉴仅采用包装内的配料和食材，采用包装后推荐的烹饪方法进行烹饪，所拍的实物照片没有进行任何的调整与修正，目的是为了让结果更加的客观公正。 170119 MyKuai红酸辣汤 下次这种面必须要用煮的，面饼有点粗，泡着不好吃。口味酸辣，有明显的虾酱的味道，带一点甜味，可能是鱼露和糖。 面饼：缺数据， 调料：9分，这个味道很开胃， 香味：缺数据，不喜欢虾酱的气味的人请慎重 外观：缺数据， 方便程度：7分， 综合：8分，各项比较均衡。170121-2220 新加坡百胜厨辣螃蟹面 煮之前才发现原来是拌面，说是要用两口锅煮，一口煮面，一口热调料。但是我调料是用沸水泡的，毕竟只有一口锅。口味咸咸，加了泰式甜辣酱，有螃蟹的味道，但是很明显不是刚做好螃蟹的那种味道。 面饼：8分，毕竟非油炸的面饼没有油炸面饼好。 调料：6分，和预计的差别比较大，虽然的确有螃蟹的感觉。 香味：6分，能很明显地闻到螃蟹的味道，但是由于是东南亚风味，所以晚上在房间里吃的人得三思。 外观：7分，还行，但是看上去不如日清等泡面“有料” 方便程度：4分，居然要用两口锅煮。。。 综合：6分，勉强及格，但是和预想差距比较大。170122-2230 MyKuai白咖喱面 老实说这款面刚吃上去是让我有点失望的，感觉就是国内康师傅香辣牛肉面的翻版嘛。但是表面的辣油下面是一种带点甘甜的白咖喱，味道比较柔和，感觉还不错。口味咸辣，表面的辣油下面是带点甘甜的白咖喱。气味中有点鱼肉罐头的味道。 面饼：8分，很普通的泡面口感，感觉和康师傅差不多。 调料：5分，吃上去第一口特别像康师傅，但是吃到后来的白咖喱给这款面涨了一点分。 香味：3分，有一种东南亚食物的味道，有小鱼干罐头的味道，带一点点甜味，但是不喜欢的人可能会觉得有点臭吧。 外观：3分，长得和康师傅香辣牛肉面一个样，你觉得分数能高到哪里？！ 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：4分，有点失望，4分不能再高了。170123-1820 新加坡百胜厨叻沙面 味道有点奇妙，是一种香甜的口感，有浓浓的椰香，还有一种东南亚风情，虾酱配合椰子的香甜给人一种热情里带着温柔的美好口感。整体口味偏甜咸，有炼乳的感觉。 面饼：8分，感觉这个面饼煮了之后变得很劲道，配合这个汤料还是不错的。 调料：7分，吃起来的感觉还可以，但是总感觉还差点，可能是我不习惯这种又咸又甜还带点奶油的口味吧。 香味：8分，闻上去是香甜的，给人一种温柔的感觉，让人特别有食欲。 外观：7.5分，白中透红的色泽还不错，至少比上一款要好很多。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：7.5分，各项比较均衡，口味也比较温婉，整体还是不错的。170125-1610 韩国农心辛拉面黑袋 请无视碗里的鸡蛋。。。面条劲道，口味咸鲜，带着辣味，虽然没有什么特色，但是各个地方都很均衡，气味温和，没有那种特别重的味道，这点和东南亚的泡面相比就特别明显，口味咸淡适中，并没有特别重的咸味或辣味。 面饼：9.5分，劲道，口感好。 调料：7分，味道均衡，虽然很普通，但是吃完后有一种回味无穷的感觉。 香味：7分，比较普通，但是吃完后味道就散掉了，整体比较均衡 外观：7分，比较普通，没有之前的泡面来的有视觉冲击力。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：8分，看上去普通，但是吃着却比较舒服，值得推荐。170126-0620 韩国八道咕咕鸡丝面 鸡丝面，算是口味比较清淡的一款泡面，气味也不大，整体特别均衡。没有康师傅那股中药味儿，面饼也比较劲道，口味咸鲜，有一点点胡椒的辣味，但却没有那股强烈的胡椒味。口味清淡。但是和东渚的鸡丝面相比，也没有那么明显的鸡肉味，不要太在意他的名字。 面饼：9分，劲道，口感不错，发现韩国的泡面面饼整体都比中国的好，不至于煮两下就烂。 调料：6.5分，比较清淡，有点鸡汤味儿，但是不是那么明显。 香味：6.5分，没有特别重的气味，整体都比较均衡。 外观：7.5分，很淡雅，看上去比较普通。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：7.5分，没有想象中的鸡汤面的感觉，但是依然不错，至少比康师傅的要好。170127-0810 印度尼西亚营多拉面 味道好极了，口味甜咸鲜，带点辣味，但辣味不是很重。味道比较经典，有一种让人吃了就停不下来的感觉。面饼比较普通，但是调料包一共5包的创意着实有诚意。气味还可以，不像其他东南亚泡面般有着十分强烈的气味，久久不散去。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：9分，一共五种调料，口味比较丰富，看上去特别有诚意。 香味：7分，不同于之前的两种东南亚泡面，这款面的气味还是很温和的，气味中带点甜味，不错。 方便程度：8分，煮法和普通泡面差不多，但这是没有汤的干拌面，总的来说还是比较方便的。 综合：9分，吃上去味道真的不错，强烈推荐。20170131-1553 韩国八道韩式炸酱面 口味甜鲜，是韩国传统的大酱风味，口味不错，也是强烈推荐。调料包味道不是特别重，吃的时候以及吃完之后不会有特别咸的味道。有一点点大酱的苦味，但是真的只有一点点，非但没有让整体失衡，反而让整体的口味变得更加均衡。唯一感觉美中不足的地方就是吃完后有一种杯盘狼藉的感觉，毕竟大酱的颜色比较深。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：9分，口味甜鲜，不是很重口，吃完后没有特别咸的负担。酱料特别醇厚，厚的哟实在无法想象。。。 香味：7分，老实说其实没什么特别的香味，就只是大酱的味道，但是气味不是特别恐怖，所以7分还是OK的。 方便程度：9分，面饼煮一下，然后往料上一放就OK了，目前觉得特别方便，但是建议料包最好加热一下。 综合：8分，吃上去的整体感觉不错，强烈推荐。170201-0831 韩国八道韩式海鲜拉面 口味咸鲜，偏辣，虽然号称是海鲜拉面，但是和东南亚的冬阴功面区别较大，口味偏淡，并不像日清或康师傅的那样有浓浓的海鲜味，整体还算均衡，最大的特点应该是它的料包里面有真·墨鱼干，当然了，其实也就只有一点点了。总体来说比较平均，但是也因此没有什么特点。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：6分，比较普通的味道，吃过后其实没有什么特别的感觉，还算可以。 香味：6.5分，也很普通，并没有什么特别的，气味不是特别大。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：6分，马马虎虎的一款，感觉没什么特点。170203-0810 新加坡百胜厨咖喱风味 感觉上像是之前的新加坡百胜厨叻沙面再加点辣，整体感觉并没有许多特别的地方。这种辣味不是特别明显，只是带了一点而已，不重，但是在整体香甜的口味里却也有一定的美感和突出。椰子粉的味道其实不错，但是这道面给人一种腻的感觉。马马虎虎吧。 面饼：8分，感觉这个面饼煮了之后变得很劲道，配合这个汤料还是不错的。 调料：6分，还可以，但是加了辣椒之后的味道感觉怪怪的。 香味：8分，闻上去是香甜的，给人一种温柔的感觉，让人特别有食欲。 外观：7分，奶油的一样的外观整体还可以，仅有的一点点辣油也起到了点缀的作用。 方便程度：7分，和普通泡面一样的做法，还算方便。 综合：7分，与叻沙面一比就觉得没有什么特色，整体还算可以，如果不喜欢奶油味或椰子味的话就不推荐了。170227-0810 印度尼西亚营多加辣拉面 和普通的营多拉面相比就是多加了辣椒，其他基本没差。 面饼：7分，面饼比较普通，就是最普通的泡面，没有特别出彩的地方。 调料：8.5分，一共五种调料，口味比较丰富，看上去特别有诚意。这款稍微加了点辣，不重。 香味：7分，不同于之前的两种东南亚泡面，这款面的气味还是很温和的，气味中带点甜味，不错。 方便程度：8分，煮法和普通泡面差不多，但这是没有汤的干拌面，总的来说还是比较方便的。 综合：8.5分，吃上去味道真的不错，推荐。]]></content>
      <categories>
        <category>傻屌如我</category>
      </categories>
      <tags>
        <tag>泡面</tag>
        <tag>进口</tag>
        <tag>品鉴</tag>
      </tags>
  </entry>
</search>
