<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[摩尔状态机和米勒状态机特性对比]]></title>
    <url>%2F2019-07-16%2Fmoore-mealy%2F</url>
    <content type="text"><![CDATA[之前对比过一段式，两段式和三段式状态机综合结果，在这个过程中发现大家对Moore状态机和Mealy状态机特别容易混淆。所以在这里专门写了这篇博文来详细介绍这些内容。 Moore状态机和Mealy状态机的对比下表以一个例子直观地对比了Moore状态机和Mealy状态机的异同，两者最大的区别在于状态机输出是否跟输入相关。 Moore状态机 Mealy状态机 Moore 状态机是时序逻辑输出只取决于当前状态的这一类状态机，其输出表达式为输出信号 = G(当前状态)。 Mealy 状态机是时序逻辑输出不但取决于状态，还取决于输入的一类状态机，其状态机输出表达式为输出信号 = G(当前状态，输入信号)。Moore 与 Mealy 状态机的互相转换根据哲学原理，讲完世界观就得讲方法论，讲完区别就得意识到事物之间是有普遍联系的，他们可以在一定条件下进行转化。状态机之间也不例外。 先讲Mealy-&gt;Moore的过程首先请出这次举例所需要的Mealy状态机，如下图： 这个状态机有三个状态：S0，S1和S2，仔细观察后不难发现指向S1的箭头有两种输出： 0和 1，指向S2的箭头也有两种输出：0和1，也就是说对于S1状态来说，状态机的输出并不仅仅与状态本身有关，还与状态机的输入有关，所以这是一个Mealy状态机。 接下来就是见证奇迹的时刻。高呼，汽车人，变形！哦，不，状态机，变形！ 第一步，先确定复位后的初始状态为S0，然后S0临近的两个状态分别为S1和S2。分别画上指向箭头，然后就存在了S0分别指向S1与S2的状态。如下图： 第二步，分析原状态机图，发现S1有两个输出，此时再使用一个状态就不太合适了，所以这时将S1拆分成两个状态：S10和S11，分别表示输出为0和1的两个状态；同理将S2也分解为S20与S21。如下图： 第三步， 在原始状态机中S1有指向S0的箭头，这两个转换过程的输出均为0，所以画两根箭头指向S0。如下图： 第四步， 参考第三步，S1在输入为0 时会指向S2，而且输出为1，所以这里画两根箭头指向S21。如下图： 第五步，在完成第四步的基础上画两根箭头由S20和S21指向S10。如下图： 锵锵，大功告成，Mealy状态机被完美改造成了Moore状态机。稍微做下整形： 再讲Moore-&gt;Mealy的过程Moore状态机转换成Mealy状态机的过程相对来说就要简单一些了。 下图是需要转换的Moore状态机。 第一步，观察状态机的组成，发现有两个状态机之间没有直接的联系，即这两个状态机之间没有箭头连接，他们就是A和D。然后观察到这两个状态机都有箭头指向状态B和状态C，所以这两个状态是可以融合的。 第二步，将A与D融合后产生新的状态AD’，同时，状态B和状态C就转变成新的状态B’和C’。然后在这个基础上进行调整和整理就得到了下面这张图。 Moore状态机与Mealy状态机的性能对比Mealy状态机Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849module top_sys ( input wire clk, input wire rst, input wire i, output reg out );reg [2:0] NS; //NextStatereg [2:0] CS; //CurrentStateparameter S0 = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= S0; else CS &lt;= NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) S0: begin if (i) begin NS &lt;= S2; end else begin NS &lt;= S1; end end S1: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S2; end end S2: NS &lt;= S1; default: NS &lt;= S0; endcaseend//3rd always block, the sequential FSM outputalways @ (*) begin case (CS) S0: out &lt;= 1'b0; S1: begin if (i) out &lt;= 1'b0; else out &lt;= 1'b1; end S2: begin if (i) out &lt;= 1'b0; else out &lt;= 1'b1; end default: out &lt;= 1'b0; endcaseendendmodule Synplify综合结果，682.2 MHz Moore状态机Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152module top_sys ( input wire clk, input wire rst, input wire i, output reg out );reg [3:0] NS; //NextStatereg [3:0] CS; //CurrentStateparameter S0 = 4'b0000;parameter S10 = 4'b0001;parameter S11 = 4'b0010;parameter S20 = 4'b0100;parameter S21 = 4'b1000;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= S0; else CS &lt;= NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) S0: begin if (i) begin NS &lt;= S20; end else begin NS &lt;= S11; end end S11: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S21; end end S10: begin if (i) begin NS &lt;= S0; end else begin NS &lt;= S21; end end S20: NS &lt;= S10; S21: NS &lt;= S10; default: NS &lt;= S0; endcaseend//3rd always block, the sequential FSM outputalways @ (*) begin case (CS) S0: out &lt;= 1'b0; S11: out &lt;= 1'b1; S10: out &lt;= 1'b0; S21: out &lt;= 1'b1; S20: out &lt;= 1'b0; default: out &lt;= 1'b0; endcaseendendmodule Synplify综合结果，614.3 MHz Moore vs Mealy 状态机这里对比了两种状态机的特点。 1. Mealy 机比 Moore 机 “响应” 速度快。 Mealy 机的输出与当前状态和输入有关，而 Moore 机输出仅与当前状态有关。Mealy 机的输入立即反应在当前周期；Moore 机的输入影响下一状态，通过下一状态影响输出。为此 Mealy 机比 Moore 机输出序列超前一个周期，即 “响应速度” 较快。Mealy 机的输出在当前周期，具有较长的路径（组合逻辑）；Moore 机的输出具有一个周期的延时，容易利用时钟同步，Moore 机具有较好的时序。 2. Mealy 机状态少，Moore 机结构简单。 由于 Moore 机的输出只有当前的状态有关，一个状态对应一个输出，Moore 机具有更多的状态。Mealy 和 Moore 机之间可以相互转化，对于每个 Mealy 机，都有一个等价的 Moore 机，Moore 机状态的上限为所对应的 Mealy 机状态的数量和输出数量的乘积。 3. 状态机的状态通过触发器的数量来反应，Mealy 机具有较少的状态，为此具有较少的触发器。 4. 血的教训告诉我，不能根据输出状态机的写法是否包含不同输入的不同输出而确定这是Mealy状态机还是Moore状态机。附录：有小伙伴表示对Graphviz生成的流程图比较感兴趣，所以在此处呈上两种状态机的Graphviz代码。 Mealy状态机123456789101112131415digraph fsm &#123; rankdir=LR; ratio=&quot;compress&quot; ranksep=1; size=&quot;8.0,8.0&quot;; node [fontsize=25]; node [shape = doublecircle]; S0; node [shape = circle]; &quot;S0&quot; -&gt; &quot;S1&quot; [label= &quot;0/1&quot;] &quot;S1&quot; -&gt; &quot;S0&quot; [label= &quot;1/0&quot;] &quot;S1&quot; -&gt; &quot;S2&quot; [label= &quot;0/1&quot;] &quot;S2&quot; -&gt; &quot;S1&quot; [label= &quot;x/0&quot;] &quot;S0&quot; -&gt; &quot;S2&quot; [label= &quot;1/0&quot;]&#125; 生成流程图如下： Moore状态机123456789101112131415digraph fsm &#123; rankdir=LR; ratio=&quot;compress&quot; ranksep=1; size=&quot;8.0,8.0&quot;; node [fontsize=25]; node [shape = doublecircle]; &quot;S0/0&quot;; node [shape = circle]; &quot;S0/0&quot; -&gt; &quot;S1/0&quot; [label= &quot;0&quot;] &quot;S1/0&quot; -&gt; &quot;S0/0&quot; [label= &quot;1&quot;] &quot;S1/0&quot; -&gt; &quot;S2/1&quot; [label= &quot;0&quot;] &quot;S2/1&quot; -&gt; &quot;S1/0&quot; [label= &quot;x&quot;] &quot;S0/0&quot; -&gt; &quot;S2/1&quot; [label= &quot;1&quot;]&#125; 生成流程图如下： 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Mealy to Moore and Moore to Mealy Transformation FSM 有限状态机 verilog三段式状态机设计实例（moore和mealy） 状态机的模型之Moore型状态机 状态机的模型之Mealy型状态机]]></content>
      <categories>
        <category>FPGA血泪史</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>有限状态机</tag>
        <tag>Moore</tag>
        <tag>Mealy</tag>
        <tag>状态机转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态机一段式、二段式和三段式写法的实际效果]]></title>
    <url>%2F2019-07-16%2Ffsm-style%2F</url>
    <content type="text"><![CDATA[根据写法不同，状态机分为一段式状态机、两段式状态机和三段式状态机。对于硬件描述语言来说，不同的写法往往会综合出不同的硬件电路。网上大多数资料都仅仅只是介绍了各种状态机的写法，而今天我要来研究研究不同写法综合出来的实际结果的差异。 好的状态机标准好的状态机的标准很多，最重要的几个方面如下： 状态机要安全，是指FSM不会进入死循环，特别是不会进入非预知的状态，而且由于某些扰动进入非设计状态，也能很快的恢复到正常的状态循环中来。这里面有两层含义：其一要求该FSM的综合实现结果无毛刺等异常扰动；其二要求FSM要完备，即使受到异常扰动进入非设计状态，也能很快恢复到正常状态。 状态机的设计要满足设计的面积和速度的要求。 状态机的设计要清晰易懂、易维护。 有限状态机有三种常见的编写方法，一段式，两段式和三段式，他们各自有着不同的优缺点，下面将进行对比。 一段式状态机 不推荐当把整个状态机写在一个always模块中，并且这个模块既包含状态转移，又含有组合逻辑输入/输出时，称为一段式状态机。不推荐采用这种状态机，因为从代码风格方面来讲，一般都会要求把组合逻辑和时序逻辑分开；从代码维护和升级来说，组合逻辑和书序逻辑混合在一起不利于代码维护和修改，也不利于约束。 特点: 1. 将所有的逻辑写在一个always块中，增加代码复杂度，给后期更改维护带来不便。 2. 由于其中有状态寄存器，整体使用non-blockin，描述输出组合逻辑时，需要提前一个时钟，需要额外注意。Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] q_sm_state );//parameterparameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//statemachinealways @(posedge clk or posedge rst) begin if(rst) begin q_sig4 &lt;= 0; q_sm_state &lt;= IDLE; end else begin case(q_sm_state) IDLE: begin if(sig1 || sig2) begin q_sm_state &lt;= WAIT; q_sig4 &lt;= 1'b0; end else begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 1'b0; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin q_sm_state &lt;= DONE; q_sig4 &lt;= 1'b0; end else begin q_sm_state &lt;= WAIT; q_sig4 &lt;= 1'b0; end end DONE:begin if(sig3) begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 1'b1; end else begin q_sm_state &lt;= DONE; q_sig4 &lt;= 1'b0; end end default: begin q_sm_state &lt;= IDLE; q_sig4 &lt;= 0; end endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 两段式状态机 推荐使用所谓的两段式状态机就是采用一个always语句来实现时序逻辑，另外一个always语句来实现组合逻辑，提高了代码的可读性，易于维护。不同于一段式状态机的是，它需要定义两个状态—-现态和次态，然后通过现态和次态的转换来实现时序逻辑。 特点: 1. 两段式状态机可以较清晰完整的显示出状态机的结构。 2. 可以轻易的将状态图state diagram转换为verilog code。 3. 代码清晰，降低编写维护复杂度。Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] current_state );reg [1:0] next_state;//参数声明parameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//状态跳转程序设计always @(posedge clk or posedge rst) if(rst) current_state &lt;= IDLE; else current_state &lt;= next_state; //状态逻辑输出always @(*) begin case(current_state) IDLE: begin if(sig1 || sig2) begin next_state = WAIT; q_sig4 = 1'b0; end else begin next_state = IDLE; q_sig4 = 1'b0; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin next_state = DONE; q_sig4 = 1'b0; end else begin next_state = WAIT; q_sig4 = 1'b0; end end DONE:begin if(sig3) begin next_state = IDLE; q_sig4 = 1'b1; end else begin next_state = DONE; q_sig4 = 1'b0; end end default: begin next_state = IDLE; q_sig4 = 0; end endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 三段式状态机 推荐使用三段式状态机与两段式状态机的区别：两段式直接采用组合逻辑输出，而三段式则通过在组合逻辑后再增加一级寄存器来实现时序逻辑输出。这样做的好处是可以有效地滤去组合逻辑输出的毛刺，同时可以有效地进行时序计算与约束，另外对于总线形式的输出信号来说，容易使总线数据对齐，从而减小总线数据间的偏移，减小接收端数据采样出错的频率。三段式状态机的基本格式是：第一个always语句实现同步状态跳转；第二个always语句实现组合逻辑；第三个always语句实现同步输出。 特点: 1. 三段式状态机可以清晰完整的显示出状态机的结构。 2. 可以轻易的将状态图state diagram转换为verilog code。 3. 代码清晰，降低编写维护复杂度。 4. 在简单状态机（状态少，转移条件少这类）的应用上，三段式代码量和一二段的比较起来长些。Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module top_sys ( input wire clk, input wire rst, input wire sig1, input wire sig2, input wire sig3, output reg q_sig4, output reg [1:0] current_state );reg [1:0] next_state;//参数声明parameter IDLE = 2'b00;parameter WAIT = 2'b01;parameter DONE = 2'b10;//状态跳转程序设计always @(posedge clk or posedge rst) if(rst) current_state &lt;= IDLE; else current_state &lt;= next_state;//状态跳转输出always @(*) begin case(current_state) IDLE: begin if(sig1 || sig2) begin next_state = WAIT; end else begin next_state = IDLE; end end WAIT: begin if(sig2 &amp;&amp; sig3) begin next_state = DONE; end else begin next_state = WAIT; end end DONE:begin if(sig3) begin next_state = IDLE; end else begin next_state = DONE; end end default: begin next_state = IDLE; end endcaseend//逻辑输出always @(posedge clk or posedge rst) if(rst) q_sig4 &lt;= 1'b0; else begin case(next_state) IDLE, WAIT: q_sig4 &lt;= 1'b0; DONE: q_sig4 &lt;= 1'b1; default: q_sig4 &lt;= 1'b0; endcase endendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 刚才的例子是一个三状态Moore状态机，状态少，也比较简单，区别效果不是很明显，接下来看一个四状态的Moore状态机，状态机之间的跳转也更加复杂。 一段式状态机Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg out );reg [2:0] NS; //NextStateparameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//1 always block to describe state transition, state output, input conditionalways @ (posedge clk or posedge rst) begin if (rst) begin NS &lt;= IDLE; out &lt;= 3'b000; end else begin case (NS) IDLE: begin if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (i1 &amp;&amp; i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i1 &amp;&amp; ~i2) begin out&lt;=3'b111;NS &lt;= ERROR;end end S1: begin if (~i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i2 &amp;&amp; i1) begin out&lt;=3'b010;NS &lt;= S2; end if (i2 &amp;&amp; (~i1)) begin out&lt;=3'b111;NS &lt;= ERROR;end end S2: begin if (i2) begin out&lt;=3'b010;NS &lt;= S2; end if (~i2 &amp;&amp; i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (~i2 &amp;&amp; (~i1))begin out&lt;=3'b111;NS &lt;= ERROR;end end ERROR: begin if (i1) begin out&lt;=3'b111;NS &lt;= ERROR;end if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end end endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 两段式状态机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg out );reg [2:0] NS,CS;parameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= IDLE; else CS &lt;=NS;//combinational condition judgmentalways @ (*) begin case (CS) IDLE: begin if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (i1 &amp;&amp; i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i1 &amp;&amp; ~i2) begin out&lt;=3'b111;NS &lt;= ERROR;end end S1: begin if (~i2) begin out&lt;=3'b100;NS &lt;= S1; end if (i2 &amp;&amp; i1) begin out&lt;=3'b010;NS &lt;= S2; end if (i2 &amp;&amp; (~i1)) begin out&lt;=3'b111;NS &lt;= ERROR;end end S2: begin if (i2) begin out&lt;=3'b010;NS &lt;= S2; end if (~i2 &amp;&amp; i1) begin out&lt;=3'b000;NS &lt;= IDLE; end if (~i2 &amp;&amp; (~i1))begin out&lt;=3'b111;NS &lt;= ERROR;end end ERROR: begin if (i1) begin out&lt;=3'b111;NS &lt;= ERROR;end if (~i1) begin out&lt;=3'b000;NS &lt;= IDLE; end end default: begin NS &lt;= CS; out &lt;= 3'b111; end endcaseendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 三段式状态机Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677module top_sys ( input wire clk, input wire rst, input wire i1, input wire i2, output reg [2:0] out );reg [2:0] NS,CS;//parameter [2:0] //one hot with zero idleparameter IDLE = 3'b000;parameter S1 = 3'b001;parameter S2 = 3'b010;parameter ERROR = 3'b100;//1st always block, sequential state transitionalways @ (posedge clk or posedge rst) if (rst) CS &lt;= IDLE; else CS &lt;=NS;//2nd always block, combinational condition judgmentalways @ (*) begin case (CS) IDLE: begin if (~i1) NS &lt;= IDLE; if (i1 &amp;&amp; i2) NS &lt;= S1; if (i1 &amp;&amp; ~i2) NS &lt;= ERROR; end S1: begin if (~i2) NS &lt;= S1; if (i2 &amp;&amp; i1) NS &lt;= S2; if (i2 &amp;&amp; (~i1)) NS &lt;= ERROR; end S2: begin if (i2) NS &lt;= S2; if (~i2 &amp;&amp; i1) NS &lt;= IDLE; if (~i2 &amp;&amp; (~i1)) NS &lt;= ERROR; end ERROR: begin if (i1) NS &lt;= ERROR; if (~i1) NS &lt;= IDLE; end default: NS &lt;= CS; endcaseend//3rd always block, the sequential FSM outputalways @ (posedge clk or posedge rst) begin if (rst) begin out &lt;= 3'b000; end else begin case (NS) IDLE: begin if (~i1) out&lt;=3'b000; if (i1 &amp;&amp; i2) out&lt;=3'b100; if (i1 &amp;&amp; ~i2) out&lt;=3'b111; end S1: begin if (~i2) out&lt;=3'b100; if (i2 &amp;&amp; i1) out&lt;=3'b010; if (i2 &amp;&amp; (~i1)) out&lt;=3'b111; end S2: begin if (i2) out&lt;=3'b010; if (~i2 &amp;&amp; i1) out&lt;=3'b000; if (~i2 &amp;&amp; (~i1))out&lt;=3'b111; end ERROR: begin if (i1) out&lt;=3'b111; if (~i1) out&lt;=3'b000; end default: out&lt;=3'b111; endcase endendendmodule Xilinx a) ISE Spartan6 RTL 原理图 b) Synplify Spartan6 RTL 原理图 c) ISE Spartan6 Technological 原理图 d) Synplify Spartan6 Technological 原理图 Altera a) QuartusII Cyclone IV E RTL 原理图 b) Synplify Cyclone IV E RTL 原理图 c) QuartusII Cyclone IV E Technological 原理图 d) Synplify Cyclone IV E Technological 原理图 结果分析1.三状态Moore状态机综合结果排序：三段式&gt;两段式&gt;一段式。可以看出，相对于一段式状态机，两段式状态机和三段式状态机所需要的硬件资源更少。 一段式 两段式 三段式 a) ISE Spartan6 RTL 原理图 b) ISE Spartan6 RTL 原理图 c) ISE Spartan6 RTL 原理图 d) ISE Spartan6 Technological 原理图 e) ISE Spartan6 Technological 原理图 f) ISE Spartan6 Technological 原理图 g) Synplify Spartan6 Technological 原理图 h) Synplify Spartan6 Technological 原理图 i) Synplify Spartan6 Technological 原理图 j) Quartus Cyclone IV E RTL 原理图 k) Quartus Cyclone IV E RTL 原理图 l) Quartus Cyclone IV E RTL 原理图 m) Quartus Cyclone IV E Technological 原理图 n) Quartus Cyclone IV E Technological 原理图 o) Quartus Cyclone IV E Technological 原理图 p) Synplify Cyclone IV E Technological 原理图 q) Synplify Cyclone IV E Technological 原理图 r) Synplify Cyclone IV E Technological 原理图 2.四状态Moore机的综合结果，两段式的资源消耗最少，三段式和一段式的综合结果就不一定了，有的情况是三段式更加节省资源，有的时候居然是一段式更加节省资源。 一段式 两段式 三段式 a) ISE Spartan6 RTL 原理图 b) ISE Spartan6 RTL 原理图 c) ISE Spartan6 RTL 原理图 d) ISE Spartan6 Technological 原理图 e) ISE Spartan6 Technological 原理图 f) ISE Spartan6 Technological 原理图 g) Synplify Spartan6 Technological 原理图 h) Synplify Spartan6 Technological 原理图 i) Synplify Spartan6 Technological 原理图 j) Quartus Cyclone IV E RTL 原理图 k) Quartus Cyclone IV E RTL 原理图 l) Quartus Cyclone IV E RTL 原理图 m) Quartus Cyclone IV E Technological 原理图 n) Quartus Cyclone IV E Technological 原理图 o) Quartus Cyclone IV E Technological 原理图 p) Synplify Cyclone IV E Technological 原理图 q) Synplify Cyclone IV E Technological 原理图 r) Synplify Cyclone IV E Technological 原理图 3.时序对比，预估时钟频率一段式和两段式的最高，三段式的频率反而最低。 一段式/MHz两段式/MHz三段式/MHz 3SM_Moore_Xilinx678.6678.6675 3SM_Moore_Altera907.9907.9907.9 4SM_Moore_Xilinx682.2682.2670.3 4SM_Moore_Altera919.6919.6907.3 4.网上找到的三种描述状态机方法的比较 5.小插曲在进行综合的过程中遇到了一个有意思的问题：Synplify没有识别状态机。综合结果只在一段式状态机中提取出了状态机，在两段式和三段式写法中居然没有提取出来。这不科学！要知道Synplify对FSM有专门的处理的，没道理提取不出来。后来发现原因是这样的：两段式和三段式状态机中状态转移部分是组合逻辑电路，一定要补全默认分支，否则就会被综合成锁存器，同时也就不会自动提取状态机信息了，这点要特别注意。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 基于FPGA的有限状态机浅析 Verilog有限状态机三段式描述方法 Verilog学习笔记（四） 有限状态机 FPGA三段式状态机的思维陷阱 Verilog语法_3(同步有限状态机) 三段式状态机设计 有限状态机FSM学习笔记 Verilog三段式状态机描述及模版 FPGA状态机 如何写好状态机]]></content>
      <categories>
        <category>FPGA血泪史</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>有限状态机</tag>
        <tag>多段式状态机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨时钟传递多个时钟信号]]></title>
    <url>%2F2019-07-16%2Fmultisignal-cdc%2F</url>
    <content type="text"><![CDATA[此文是对Clifford E. Cummings 大神的 paper：《Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs》的部分节选与翻译。本人翻译水平有限，还望大家轻拍。以后如果在实际场景中遇到相同或类似的问题，到时候再会补充的。 原文A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. Simply using synchronizers on all control signals is not always good enough as will be shown in the following examples. If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs. 译文对于工程师而言，在处理跨时钟域问题的过程中一个常犯的错误就是在将多个信号从一个时钟域传送到另一个时钟域的过程中忽略控制信号之间的时序。对所有信号仅使用同步器进行同步对于下面要介绍的应用场景是不够的。如果信号顺序和信号间的对齐很重要，那么在处理的过程中就需要格外小心了。接下来举的例子都是简化过后的案例，但是跟实际情况中经常遇到的问题非常类似。 问题1： 传递两个同时需要的信号(b_load和b_en)原文In the simple example shown in Figure 8, a register in the new clock domain requires both a load signal and an enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded. 译文正如下图案例中介绍的那样，在新时钟域中的这个寄存器需要一个负载信号和一个使能信号以保证寄存器的输入值有效。即使负载信号和使能信号都出自于同一个时钟域，两个信号间依然有概率会产生一个小的抖动，这有可能会使这两个信号在新的时钟域被同步入不同的时钟循环。在这个案例中，这就可能导致数据无法被寄存器正确识别。 图1 问题：传递两个同时需要的信号 解决方法：只传递一个信号(b_lden)原文The solution to the problem in this simple example is easy. As shown in Figure 9, drive both the load and enable register input signals in the new clock domain from just one control signal. This will remove the potential for the control signals arriving shifted in time. 译文解决这个问题的方法其实哼简单。正如下图介绍的那样，将寄存器的两个驱动信号合并成一个控制信号，然后传送入新的时钟域。这种方法将移除控制信号到达新时钟域后产生错位的可能。 图2 解决方法：只传递一个信号 问题2：传递两个前后顺序控制的信号(ben1和ben2)原文The diagram in Figure 10, shows two enable signals, aen1 and aen2, that are used to enable the sequential passing of a data signal through a short pipeline design. The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop. 译文下图中的两个使能信号aen1和aen2用于在一个流水线结构中顺序地将数据信号进行传送。这里的问题在于：在第一个时钟域，信号aen1可以在信号aen2置位前立刻结束，但是第二个时钟域可能会对aen1与aen2之间的这个极窄的空隙时间进行采样，这就导致在第二个时钟域中的使能控制信号链会产生一个时钟的空缺，这也将导致a2输出信号被第二个触发器错过。 图3 问题：传递两个前后顺序控制的信号 解决方法：只传递一个信号(ben1)原文The solution to the problem, as shown in Figure 11, is to send only one control signal into the new clock domain and generate the second phase-shifted sequential control signal within the new clock domain. 译文下图显示了解决这个问题的一种方法：将一个时钟信号传递到新的时钟域并在新的时钟域产生第二个相移顺序控制信号。 图4 解决方法：只传递一个信号 问题3：传递两个编码控制信号(bdec[0]和bdec[1])原文The diagram in Figure 12 shows two encoded control signals being passed between clock domains. If the two encoded signals are slightly skewed when sampled, an erroneous decoded output could be generated for one clock period in the new clock domain. 译文下图显示了另外一种常见的问题：两个编码控制信号在时钟域间传递。如果这两个编码控制信号间极窄的抖动被采样到，那么在新的时钟域就会产生一个时钟的编码输出误差。 图5 问题：传递两个编码控制信号 解决方法1：产生一个ready信号(bden_n)来指示数据的有效性原文One potential solution to this problem, as shown in Figure 13, is to send a shaped enable signal to act as a “ready flag” in the new clock domain. The sending clock domain must generate and enable signal one clock cycle after asserting the decoder inputs. The sending clock domain must also remove the enable signal one clock cycle before de-asserting the decoder inputs. As described earlier, the enable signal must be asserted for a time period that is longer than the cycle time of the receiving clock domain. 译文第一种解决方法是发送一个经过整形的使能信号，这个信号在新时钟域中的作用就是一个“准备妥当标志位”。在编码输入信号置位后发送时钟域必须生成和使能一个时钟的信号。发送时钟域必须在输入信号复位前一个时钟移除使能信号。正如之前所提到的那样，使能信号必须置位一个时钟周期，并且这个时钟周期必须小于接收时钟域的一个时钟周期。 原文Under worst case conditions, the shaped enable signal will either be sampled at the same time as the encoded inputs are sampled into the receiving clock domain, or the shaped enable signal will be de-asserted at the same time as the encoded inputs are de-asserted in the receiving clock domain. Under best case conditions, the shaped enable pulse will be asserted one receiving clock cycle later than the assertion of the encoded inputs and de-asserted one receiving clock cycle before the de-assertion of the encoded inputs. This method insures that the encoded inputs are valid before they are enabled into the receiving clock domain. 译文在最坏的条件下，整形后的使能信号既不会在编码输入被接收时钟域采样的同时被采样到，也不会在编码输入在接收时钟域复位的同时而复位。在最好的情况下，整形后的使能信号会在编码输入置位的一个时钟后置位，并且在编码输入复位的一个时钟前复位。这种方法可以保证编码输入在接收时钟域使能前就有效了。 图6 解决方法1：产生一个ready信号(bden_n)来指示数据的有效性 解决方法2：使用one-hot key信号结合状态机来处理接收到的信号原文A second potential solution to this problem, as shown in Figure 14, is to decode the signals back in the sending clock domain and then send the decoded outputs (where only one of the outputs is asserted) through synchronizers into the new clock domain. Within the new clock domain, a state machine is used to determine when a new decoded output has been asserted. If there are no decoded outputs, it means that one decoded output has been de-asserted and that another decoded output is about to be asserted. If there are two asserted decoded output signals, the last decoded output signal will cause the state machine to change states and the older decoded output signal will turn off on the next rising clock edge in the new clock domain. It is important that the sender insure that the decoded outputs are each asserted for a time period that is longer than the cycle time of the receiving clock domain. 译文如下图显示，第二种解决这个问题的方法是在发送时钟域将信号进行编码，然后将编码后的信号（独热码）通过同步器发送到接收时钟域。新的时钟域中有一个状态机用来决定编码输出何时被置位。如果此时没有编码输出，这就意味着一个输出已经被复位了而另一个输出正准备置位。如果此时有两个编码输出置位，新的编码输出信号将导致状态机状态改变，而上一个编码输出信号将在新时钟域的下一个时钟上升沿复位。需要特别注意的是，发送端必须保证编码输出一次仅置位一个时钟周期，并且这个时钟周期不会比接收时钟域的一个时钟长。 原文Any time there are multiple control signals crossing clock boundaries, caution must be taken to insure that the sequencing of the control signals being passed is correct or that any potential mis-sequencing of the control signals will not adversely impact the correct operation of the design. 译文凡是在有多个控制信号跨越时钟边界的时候，控制信号必须保证时序正确，或者控制信号的任意潜在失序将不会影响这个设计的正确操作。 图6 解决方法2：使用one-hot key信号结合状态机来处理接收到的信号 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
      </categories>
      <tags>
        <tag>异步时钟</tag>
        <tag>多信号同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步时钟信号同步化及其综合结果]]></title>
    <url>%2F2019-07-16%2Fasync-clock-sync%2F</url>
    <content type="text"><![CDATA[异步时钟处理是每个使用FPGA的工程师都必须要掌握的技巧。可以说，如果你不会处理异步时钟信号，那么我会认为你压根儿就没用过FPGA。这里总结了三种常见的异步时钟处理方法，并且在仿真中验证过。 通常使用 MTBF (Mean Time Between Failures) 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×10^9 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。 理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。 如图所示： 图1 同步器结构 通常，同步器由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。 为了让同步器正常工作，从某个时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入同步器。之所以这样要求，是因为同步器的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过同步器，给新时钟域后续逻辑一个虚假的信号。 同步器有很多设计方法，因为一种方法不能满足所有的应用需求。同步器的类型基本上分为 3 种： 1. 电平同步器 2. 边沿检测同步器 3. 脉冲同步器下面分别讨论： 电平同步器Schematic: 图2 电平同步器结构 电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 paper 中有更详细的图解说明： 图3 电平同步器详细介绍 Code:123456789101112131415161718192021222324252627282930module LVLSYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output reg dat_dst );// source time domainreg dat;always @(posedge clk_src) begin if (rst_src) begin dat &lt;= 1'b0; end else begin dat &lt;= dat_src; endend// destination time domainreg dat_r;// using two level DFF to synchronize the din_qalways @(posedge clk_dst) begin if (rst_dst) begin dat_r &lt;= 1'b0; dat_dst &lt;= 1'b0; end else begin dat_r &lt;= dat; dat_dst &lt;= dat_r; endendendmodule RTL: 图4 电平同步器RTL图 SIM: 图5 电平同步器仿真图 Restriction:使用电平同步器的要求是： 1. 源时钟域的信号应先通过源时钟域的一个 DFF 后输出，然后直接进入目的时钟域的同步器的第一级 DFF。这么做到原因是：同步器的第一级 DFF 对组合逻辑产生的毛刺（glitch）非常敏感。如果一个足够长的毛刺刚好满足了 setup/hold time，那么同步器会将其放行，产生一个虚假的信号。 2. 跨域时钟域的这个信号持续时间 &gt;= 2 个新时钟域时钟周期。虽然 Crossing the abyss: asynchronous signals in a synchronous world 中是这么写的，但是我觉得这个条件应该是保险条件，而不是最低条件。 电平同步器的最低条件应该和边沿检测同步器相同： 输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。 首先，待同步到信号宽度 &gt; 源时钟周期，这样它才能被源时钟域的 DFF 采样到，然后输出； 其次，源时钟域采样输出端信号的宽度当然是源时钟周期的整数倍，它的宽度 &gt; 目标时钟域周期 + 第一个 flip-flop 的 hold time，这样它才能被目的时钟域的时钟采样到，然后进行同步。 所以，保险一点的条件是：待同步到信号有效时间至少是目的时钟周期的 2 倍。电平同步器是其他两种同步器的基础： 边沿检测同步器边沿检测同步器 是在电平同步器的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。 Schematic: 图6 边沿检测同步器结构 Code:123456789101112131415161718192021222324252627282930module EDGESYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output wire dat_dst );// source time domainreg dat;always @(posedge clk_src) begin if (rst_src) begin dat &lt;= 1'b0; end else begin dat &lt;= dat_src; endend// destination time domainreg [2:0] sync_reg;always @(posedge clk_dst) begin if (rst_dst) begin sync_reg &lt;= 3'b0; end else begin sync_reg &lt;= &#123;sync_reg[1:0], dat&#125;; endend// AND to get the outputassign dat_dst = sync_reg[1] &amp;&amp; (~sync_reg[2]);endmodule RTL: 图7 边沿检测同步器RTL图 ###SIM: 图8 边沿检测同步器仿真图 Restriction:使用边沿检测同步器的要求是： 1. 输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。实际上，因为在源时钟域，要先用 DFF 寄存一下再输出，所以源时钟域输出的信号的宽度是其时钟周期的整数倍，它肯定是 &gt; 目标时钟周期的，因为边沿检测同步器只能工作在慢时钟域到快时钟域的情况下。边沿检测同步器在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用脉冲同步器。 脉冲同步器脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。源时钟域的单时钟宽度的脉冲不是直接输出的，而是先经过一个源时钟域的翻转电路。这个翻转电路在每次输入一个脉冲时，它的输出会在高、低电平之间翻转。而在目的时钟域，翻转电路的输出先通过一个电平同步器，其输出到达异或门的一个输入端，而这个输出再经过一个 DFF，延时一个时钟周期后进入异或门的另外一个输入端。最后异或门的输出即最终的同步结果：源时钟域每有一个单时钟脉冲（源时钟），同步器的输出端产生一个单时钟宽度（目的时钟）的脉冲。 Schematic: 图9 脉冲同步器结构图 Code:123456789101112131415161718192021222324252627282930313233module EDGESYNC( input wire clk_src, input wire rst_src, input wire dat_src, input wire clk_dst, input wire rst_dst, output wire dat_dst );// source time domainreg toggle_reg;always @(posedge clk_src or posedge rst_src) begin if (rst_src) begin toggle_reg &lt;= 1'b0; end else begin if (dat_src) begin toggle_reg &lt;= ~toggle_reg; end endend// destination time domainreg [2:0] sync_reg;always @(posedge clk_dst) begin if (rst_dst) begin sync_reg &lt;= 3'b0; end else begin sync_reg &lt;= &#123;sync_reg[1:0], toggle_reg&#125;; endend// XOR to generate the pusle_dstassign dat_dst = sync_reg[1] ^ sync_reg[2];endmodule RTL: 图10 脉冲同步器RTL图 SIM： 图11 脉冲同步器仿真图 Restriction:使用脉冲同步器的要求是： 1. 输入脉冲之间的最小间隔 &gt;= 2 个同步时钟周期。如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻，形成一个比单时钟周期宽的输出脉冲。 实际上，在一些情况下，少于 2 个时钟周期（&gt; 1 个时钟周期）也是可以同步上的。只要同步器的两个 DFF 的值不一样即可同步上，也就是说异步信号在连续的两个目的时钟采样的值不同即可，由于异步信号和时钟的相位关系不确定，所以在没有对齐的情况下，大于 1 个时钟时也能满足两个采样值不同的条件。 一般为了保险起见，要求其保持至少两个时钟宽度。时钟消耗同步器需要花费 1～2 个时钟周期来完成同步，所以粗略的估计可以认为同步器会造成目的时钟域的 2 个周期的延迟，我们在设计时需要考虑同步器对时序产生的影响。 总结总结3种同步器的特点，有下表： 图12 三种同步器的优缺点比较 虽然还有其他类型的同步器，但是这 3 种基本上就可以解决设计中遇到的多数问题了。 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 跨越鸿沟：同步世界中的异步信号 cpu与fpga跨时钟域数据交换的实现问题 FPGA 时钟设计 3 —— 跨时钟域设计 跨时钟域设计的一点总结 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs]]></content>
      <categories>
        <category>FPGA血泪史</category>
      </categories>
      <tags>
        <tag>异步时钟</tag>
        <tag>电平同步</tag>
        <tag>边沿检测同步</tag>
        <tag>脉冲同步</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程存档文件夹命名]]></title>
    <url>%2F2017-07-17%2Ffolder-manage%2F</url>
    <content type="text"><![CDATA[对于我这种强迫症，工程管理都做了，那怎么能不顺便做一下文件夹的命名管理呢？奸笑 我的工程文件夹使用扁平化的存放形式，那是因为我不喜欢文件夹套文件夹的存放方式，一级地找文件就像是在迷宫中找出口一样复杂。 AA_Buf: 临时存放，之后需要整理 BB开头的文件夹代表上位机软件相关(binary的简称)： BT开头的文件夹代表已编译的可执行文件 T代表Tool BXX代表含源码的工程，B后的两位代表编程语言，例如BCC就是使用C语言的工程 #由于编程语言较多，程序语言使用双字编码，其中： CC：C语言； CS: C#； CP: C++； VR: Verilog ； VH: VHDL UU: 不确定 JS: Json JV：JAVA VB：Visual Basic； BT:批处理指令； MT：Matlab； JS:Jason； CP:Citespace; BXXR代表含源码的参考工程，注释同上 BSYS代表操作系统 PET:petalinux； AND：安卓； UBN：Ubuntu 后面加上版本号，例如： BSYS_PET_1704_FullBioSignal_Phase2CC开头文件夹代表结构设计相关： 第二个字母代表模型格式 S: SOLIDWORKS; C: CREO; A: AUTOCAD的DWG,DXF文件； D: PDF; T: STEP 同一个文件夹中若同时包含几种模型格式，则按照SAC顺序排序 第三个字母代表模型用途 R:参考设计（Reference）； D：草稿（Draft）； L：库（Library）； E：PCB模型，用于和结构工程师交互； S：仿真（Simulation）。 第四个字母代表模型库的细分类 P:泵（PUMP）； V:阀（Valve）； J:接头（Junction）EE开头的文件夹代表PCB工程 EX_板号_XXX_RX 电子设计的工程文件,尾缀是版本号，R是状态，R代表原型设计，D代表设计 EXL_XXX 某个项目的临时库 EXR_XXX 电子设计的参考设计 其中，使用一个字母表示文件格式： C:Cadence； A：Altium； P：PADS； D：PDF； E：Eagle； X：EE； G：GERBER 如果有多个文件的，按照CAPDEXG的顺序取第一个字母。FF开头的文件夹代表固件相关(firmware的简称)： FXX代表含源码的工程，F后的两位代表编程语言，但是之后需要加上主芯片和IDE的代号. 例如FCC_430_I_XXXX就是使用C语言的工程，主芯片为430，IDE为IAR Xilinx ： SP7：Spartan-7； AX7：Artix-7； ZQ7：Zynq-7； KX7：Kintex-7； Altera： AA10：Arria-10； MX10：Max-10； SR10：Stratix-10； CY10：Cyclon-10. #由于编程语言较多，程序语言使用双字编码，其中： CC：C语言； CP: C++； VR: Verilog ； VH: VHDL UU: 不确定 #IDE代码： I: IAR K: KEIL C: CREATER A: ANDES H: HOLTEK U: 无IDE S: SILICON STUDIO V: VIVADO Q: QuartusII S: ISE 如果有多个IDE的，按照KIUCHAS顺序排序 FXXR代表含源码的参考工程，注释同上 FXXL_MAIN-IC_LIB_VERSION 存放官方的库文件，例如STM32和EFM32的库，但是TI提供的却只是例程，不算是库。 另外，我自己写BSP暂时不进行归档处理，因为各种硬件差别比较大，所以也没必要做通用适配，等要用到的时候再复制即可。RR开头的文件夹代表网上下载的资料文件(reference的简称)： R后面可以有第二个字母用来对内容进行细分,比如： RD开头的文件夹代表设计思路相关(design的简称)： RP开头的文件代表有详细文件的参考工程 RC开头的文件夹代表结构参考工程 RCX_开头的文件夹代表某大类结构件相关规格书，例如RCP代表的就是泵,其中: P: 泵； V: 阀； RE开头的文件夹代表电子相关资料： REX_开头的文件夹代表某大类电路元器件, 例如REC代表的就是电容 细分类同原理图库 规格书格式 厂家名_型号_功能描述 RS开头的文件夹代表仿真相关资料 RSX_开头的文件夹代表相应工具的参考资料，例如RSC代表的就是PSPICE的相关资料,其中: C：Cadence（Pspice）； S：Saber；MM开头的文件夹代表生产相关的文件，需要特别注意别弄混 M_XXX 指向的是某个项目的具体加工或报价或采购记录，内容可以考虑用压缩包的形式样品采购文件夹存放采购相关信息，主要是单独物料采购，供货商的样品采购。 一定要加上供货商的详细信息。SS开头的文件夹代表仿真相关文件，仿真用的文件，特别需要注意删除一些不是很重要的仿真结果，免得占地方,不需要在所有客户端都进行同步，这些可以使用Git进行管理 第二个字母代表仿真内容： C：结构； E：电子相关； H：热力学仿真 第三个字母代表仿真工具 A：ANSYS相关软件； C：Cadence； L：LTSPICE； S:Saber； M：Comsol； T:TINA 第四个字母L代表相关软件的库TT开头的文件夹代表测试数据，测试报告等文件，不需要在所有客户端都进行同步 T_WM_XXXXXX_具体内容 实验数据和实验报告的命名方式可能还得再考虑考虑 图片类的实验数据要写明是做什么用的VV开头的文件夹存放音频和视屏文件，用于存放极其重要的音视频文件，这个比较占地方，需要及其注意 ZzRubbish文件夹用来存放没什么用可以删掉的资料 最后来一张效果图：]]></content>
      <categories>
        <category>强迫症专题</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>工程存档</tag>
        <tag>扁平化命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file-manage]]></title>
    <url>%2F2017-07-17%2Ffile-manage%2F</url>
    <content type="text"><![CDATA[对于我这种重度强迫症患者来说，多台PC间、以及多个项目间的文件管理一直是令我抓狂的地方。所以最近抽了一段时间来进行文件的整理，研究了一下Git、云盘以及符号链接的特性，并根据自己的使用习惯进行了设计。这里将这部分经验分享一下。 以下内容适合有多台PC的Windows用户，只有一台PC（以后也不会同时用多台PC）的人可以不看了，用MAC的土豪不用看了，因为没在MAC上试过（估计也不行），用Linux的人也不用看了，理由同上。 与其说是NAS,云盘和Git的使用心得，不如说是建立了一套基于中心库的文件管理方式。 背景：假设有四台电脑：第一台台式机，放在办公室作为主力PC；第二台台式机，放在实验室用于调试；第三台台式机，放在家里；第四台笔记本，随身携带。开始蛋疼了： PC1： C:30G D:200G E:200G F:1.5T PC2： C:60G D:200G PC3： C:256G D:256G E:150G F:500G G:1.5T PC4： C:512G蛋疼点1：假如在办公室改的图纸，要拿到实验室去调，发现一些问题需要晚上拿回家再改，那样就得需要用个U盘从这台PC拷到另一台PC，拷来拷去，如果中间还需要修改和添加批注的话，时间一长，自己也很有可能不知道哪个文件是哪个版本。。。 蛋疼点2：假设AD指向的库目录没法一致，例如PC1指向的是D盘，PC3指向的是G盘，PC4指向的是C盘。那么当把一个项目从PC1拷到PC3的时候就会出现一大堆弹窗，通知你没找到库，然后就得一个个手动添加，AD指向的库目录有的还特别深，感觉整TM不爽。。。 蛋疼点3：如果各个项目之间有交叉有耦合，例如项目1里面的器件可以在项目2里面用，在项目1的规格书里添加了备注，这时候项目2开始了，可以把项目1的文件复制到项目2，之后又在项目2中添加备注，多次往复添加的备注就会不一样，时间一长铁定遗忘。 蛋疼点4：使用Onenote和Endnote的时候，不建议直接将文件附件直接插入，理由同上，会导致同一个文件有多个版本，内容会不一致；也不建议直接打印到笔记本里，因为Onenote会打印成图片，小的文件还好，大的文件就会大大增加Onenote的体积，3M的PDF就可能会变成100M+的图片，十分蛋疼。这种时候就建议有一个指向链接，链接到相应的文件，而假如在不同的电脑上链接的位置不一样就又会导致蛋蛋火辣辣地疼。 蛋疼点5：如果直接使用NAS等网盘工具进行同步的话，需要同步的代码编译出来的一大堆文件不光占地方，而且极容易导致同步冲突。虽然可以添加文件例外，但是不同项目有着不同的要求，每一个都不太一样，无法使用通用的文件例外适配所有程序。 蛋疼点6：有些文件不希望他实时同步，例如Comsol的文件，结果会存在mph文件中，使得文件特别大，这种文件一般是希望把结果删掉之后再保存的，不然的话，一下子就好几个G，没有哪个网盘可以HOLD住的。 ———————————————-还要用，所以不割———————————————— 首先要大致介绍一下符号链接：这东西就类似于指针，假设把G:\Lib指向C:\Lib，文件的位置依然在G:\Lib，但是操作C:\Lib中的文件也会有同样地更改，这点类似于快捷方式。但是它不同于快捷方式的地方在于： 1. 快捷方式其实是一个.INK的文件，使用资源管理器打开；符号链接只是一个指向链接，由操作系统调度。 2. 其他软件中是无法打开快捷方式的，但是可以打开符号链接。 3. 复制快捷方式得到的还是快捷方式，但是复制符号链接得到的是源文件。例如你复制C:\Lib，其实得到是G:\下的文件。Git的介绍再另一篇里有，在此不再赘述。 —————————————————可以割了—————————————————- 接下来就是见证奇迹的时刻如下图所示，所有文件夹的真实位置在G盘根目录下，先将所有目录在C:/CentralLib中进行重新分配，尽可能设计成扁平化的文件夹风格。因为每台windows电脑肯定有C盘（什么？你的windows装在了D盘！好吧，你牛X），这样就让系统误认为所有文件都在C盘。然后从C盘将文件分别映射到E:/Work下的各个工程文件夹，这样就能保证不同的工程文件夹后来用的是同一套库了。 特点： 网盘适合同步几十K~几十M的文件，最好是不会产生大量临时文件的那种，即使产生临时文件也是可以随时删掉而不会对文件造成影响。例如PDF,OFFICE文档，pcb文件，压缩后的工程存档。 NAS因为是内网，所以同步速度特别快，除了对网盘文件进行同步以外，还可以对一些临时性的文件进行快速同步，以免文件丢失。例如网上下载到的参考固件，网上下到的一些小工具等。 GIT适合对二进制文件同步，因为它每次只上传修改后的部分，而且可以手动调整分支，可以指定上传的文件。这些性质对于代码，仿真这种可能会有多种分支，试错成本又低的场合是非常合适的。 使用符号链接，在C盘创建一个虚拟的中心库，然后再将工作盘和其他文件指向这个中心库，原始文件则可以按照各自最合适的方式进行同步。 没有适配所有文件的同步方式，建议使用各自最合适的同步方式来同步。 当项目需要存档和打包的时候，直接复制就可以了，复制符号链接得到的是源文件。 2019-03-01 更新最近确定硬盘挂了，在酿成大错之前赶快备份数据，这时候之前的符号链接让我犯难了，不能直接copy，这样的话会将源文件直接复制过去的，所以这里用了xcopy指令。 复制包含符号链接的目录： 1xcopy e:\test j:\test /e /B 源 e:\test 目标 j:\test]]></content>
      <categories>
        <category>强迫症专题</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>云盘</tag>
        <tag>Git</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git管理工程的方法]]></title>
    <url>%2F2017-07-16%2Fuse-git%2F</url>
    <content type="text"><![CDATA[Git是当下最流行的工程管理方法，作为一个硬件工程师，也得要跟上时代的脚步，努力学习其他行业的技术优点。在了解了Git之后，发现它是当之无愧的神器，用Git就是爽，一直Git一直爽！ 首先讲一下为啥要用Git 不使用Git 使用Git Git特别适合代码这种试错成本低，迭代快速，带有尝试性质的场合。 简单讲一下Git， Github，SVN之间的联系与区别Git和SVN都是一种文件管理方式：Git是基于分布式库管理设计的，在本机上会有一个仓库，同时，也可以在云端有一个仓库，所以没有服务器端其实也可以提交和版本备注；SVN是集中式管理的，仓库直接上传到服务器端，没有服务器端就基本上用不了。GitHub是众多基于Git技术的管理服务器端之一，他们做的基于Git的客户端工具叫做GitHub-Desktop。此外，还有Sourcetree，GitKraken等。 所以，正确的层次结构应该是这样的： 项目管理技术服务器客户端 GitGitHubGitHub-Desktop AtlassianSourceTree GitKrakenGitKraken GitLab无 无TortoiseGit 无Git（Git原生的客户端） SVN没了解过没了解过 PS： 1. 以前免费版的GitHub账户只能创建公开仓库，自从巨硬收购了GitHub后，现在免费版账户也能创建私有账户了。 2. Git的项目文件夹可以用上述任何一款客户端打开和编辑，他们是标准格式，不会有冲突。 3. 虽然有些Git客户端会自带Git控制台，但是不建议把这种Git控制台用作全局使用，因为他们的路径名称中有软件自己的名字和版本号，更新几次后会导致路径名失效。实验室用群晖搭建了GitLab，接下来就让咱们来试用一下吧 准备工作：1.git客户端1.产生gitlab服务端和本地git相互传输时所需要校验的私钥和公钥 2.直接在Idea中使用git提交和push代码，当然也可以用sourcetree提交代码 2.sourcetree客户端1.拉取远端服务器代码到本地 2.push本地代码到远端 3.创建分支，解决提交代码中的冲突 3.gitlab账号（一般公司配置，用自己的邮箱）1.建立远端分支，可追踪 2.本地和远端代码的修改活动详细显示 3.云储存库，储存代码 一句话就是gitlab中存储着远端的代码，git是本地代码和远端代码沟通的桥梁，不过是用命令行的形式，sourcetree是将git变为可见的客户端。 软件安装（以SourceTree为例，其他软件类似）：1.安装git客户端（Git-2.14.0-64-bit.exe）一路Next，但是最后一步有一个是否允许符号链接的勾，按照个人需要选择。不管你选没选，我反正是选了。 2.安装SourceTree（SourceTreeSetup-2.1.2.5.exe） 需要申请一个账户（反正也免费，申就申吧），一路Next。假如GitHub上已经有库的话就可以在这个时候同步下来，没有的话也没关系，反正之后要再建的。当问及是否要创建SSH的时候选否吧，反正之后要手动创建的。 在windows下安装时，当需要使用内置的git，hg时，需要从atlassian.com网站下载。不知道什么原因，总是下载失败。使用Chrome是能够自己下载这两个文件的。使用代理也不好用。所以只有自己下载之后，放在这个目录下，才会好用。 c:\users\YOURUSERNAME\AppData\Local\Atlassian\SourceTree, 把下载好的压缩包解压缩到这个目录下。Git对应git_local,HG对应hg_local。这样就可以在SourceTree中设置使用内置的git和hg了。 另外，需要下载的压缩文件的URL可以在这个目录下的sourcetree.log中找到。下载失败之后会在这里纪录URL。 3.至此软件安装完毕使用SSH链接GitLab：1.利用git bash生成公钥和私钥（使用git bash命令生成gitlab服务端和本地git相互传输时所需要校验的私钥和公钥，公钥用于配置gitlab，私钥用户配置sourcetree。） 打开git bash,输入以下命令： （1）设置git的user name和email：12$ git config --global user.name "test"$ git config --global user.email "test@gmail.com" （2）生成SSH密钥过程：1.查看是否已经有了ssh密钥： 1cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 2.生成密钥：（注意ssh与参数之间没有空格！！！） 1$ ssh-keygen -t rsa -C “邮箱地址” -C 选项后是备注，可随意。命令执行后会要求输入key存储的文件名和passphrase： • 输入一个特有的文件名，否则使用默认的 id_rsa。 • passphrase。不输入也可以。输入之后，提交的时候要输入这个passphrase完成后在 ~/.ssh/ 会生成2个文件。id_rsa 和 id_rsa.pub。前者是私钥，注意保管，后者是公钥。在这里按3个回车，密码为空就可以了。 此时在.ssh文件夹下回生成下面3个文件， 2.在gitlab中配置公钥登录gitlab-&gt;project setting-&gt;SSH,添加即可 打开id_rsa.pub，把内容复制进去 显示如下就OK了 3.sourceTree配置的私钥，与gitlab公钥对应打开sourcetree,点击工具》选项》一般，设置公钥的路径即可。注意客户端选择：OpenSSH 在GitBash中ping一下试试 这样就可以配置成功了！！！ ———————————-华丽丽的分割线———————————- 4.拉取远端代码到本地仓库在gitlab中寻找需要拉取的仓库地址，如下： 在sourcetree中，选择克隆/新建仓库，填写远端和本地的仓库路径，添加即可，之后直接pull 仓库即可。 这样以后可以直接在sourcetree拉取代码了。这里的URL格式需要修改如下： 注意，这次实验使用的端口是8022，具体出现问题的话可以问问我。 Git管理Keil工程：其实很简单，建立仓库后直接把对应的.gitignore文件和工程文件放到Git仓库中，就可以进行commit和push了。 Gitserver建立git仓库的方法群晖的Gitserver不支持通过SSH来登录，所以最好找一个支持账户密码存储的客户端T_T 下面是记录群晖Gitserver创建仓库的方法，以后写个脚本让他自动装机创建吧。 123456789101112cd /volume1/git_reposmkdir xxxx.gitcd xxxx.gitgit init --baresudo -i // 取得root权限cd /volume1/git_repos/chown catonblack:users . // 将gitReposTest目录的所有者改为管理员账户aulati，目录的所属群组改为users。注意不要忘了[.]chmod 770 . // 将gitReposTest目录的所有者、所属群组的权限改为 读/写/运行chown -R git:users xxxx.git // 改变test.git目录及所有包含文件、子目录的所有者chmod -R 770 xxxx.git // 改变test.git目录及所有包含文件、子目录的权限git clone ssh://git@192.168.3.5:9022/volume1/git_repos/test.git 参考资料这篇笔记参考网上众多资料实验并整理而成，如果涉及侵权烦请请告知，我将第一时间处理。 漂亮的git分支图 Keil-MDK 使用 Git 作为项目版本管理工具 Keil协同开发存在的问题 Git管理Keil工程实录 解决 需要生成 多个SSH key 的问题]]></content>
      <categories>
        <category>工具使用技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Gitlab</tag>
        <tag>GitHub</tag>
        <tag>GitServer</tag>
      </tags>
  </entry>
</search>
